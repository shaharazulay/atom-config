"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _class, _temp2;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

// components

var _react = require("react");

var _react2 = _interopRequireDefault(_react);

var _d3Scale = require("d3-scale");

var _axis = require("./visualizationLayerBehavior/axis");

var _Axis = require("./Axis");

var _Axis2 = _interopRequireDefault(_Axis);

var _DownloadButton = require("./DownloadButton");

var _DownloadButton2 = _interopRequireDefault(_DownloadButton);

var _Frame = require("./Frame");

var _Frame2 = _interopRequireDefault(_Frame);

var _xyframeRules = require("./annotationRules/xyframeRules");

var _general = require("./visualizationLayerBehavior/general");

var _lineDrawing = require("./svg/lineDrawing");

var _AnnotationCallout = require("react-annotation/lib/Types/AnnotationCallout");

var _AnnotationCallout2 = _interopRequireDefault(_AnnotationCallout);

var _frameFunctions = require("./svg/frameFunctions");

var _downloadDataMapping = require("./downloadDataMapping");

var _coordinateNames = require("./constants/coordinateNames");

var _dataFunctions = require("./data/dataFunctions");

var _unflowedFunctions = require("./data/unflowedFunctions");

var _multiAccessorUtils = require("./data/multiAccessorUtils");

var _frame_props = require("./constants/frame_props");

var _SpanOrDiv = require("./SpanOrDiv");

var _SpanOrDiv2 = _interopRequireDefault(_SpanOrDiv);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var naturalLanguageLineType = {
  "line": { items: "line", chart: "line chart" },
  "cumulative": { items: "line", chart: "cumulative chart" },
  "cumulative-reverse": { items: "line", chart: "cumulative chart" },
  "linepercent": { items: "line", chart: "line chart" },
  "stackedarea": { items: "stacked area", chart: "stacked area chart" },
  "stackedarea-invert": { items: "stacked area", chart: "stacked area chart" },
  "stackedpercent": { items: "stacked area", chart: "stacked area chart" },
  "stackedpercent-invert": {
    items: "stacked area",
    chart: "stacked area chart"
  },
  "bumparea": { items: "ranked area", chart: "ranked area chart" },
  "bumparea-invert": { items: "ranked area", chart: "ranked area chart" },
  "bumpline": { items: "ranked line", chart: "ranked line chart" },
  "difference": {
    items: "line",
    chart: "difference chart"
  }
};

var emptyObjectReturnFunction = function emptyObjectReturnFunction() {
  return {};
};
var emptyStringReturnFunction = function emptyStringReturnFunction() {
  return "";
};

var xyframeKey = "";
var chars = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
for (var i = 32; i > 0; --i) {
  xyframeKey += chars[Math.floor(Math.random() * chars.length)];
}var projectedCoordinateNames = {
  y: _coordinateNames.projectedY,
  x: _coordinateNames.projectedX,
  yMiddle: _coordinateNames.projectedYMiddle,
  yTop: _coordinateNames.projectedYTop,
  yBottom: _coordinateNames.projectedYBottom,
  xMiddle: _coordinateNames.projectedXMiddle,
  xTop: _coordinateNames.projectedXTop,
  xBottom: _coordinateNames.projectedXBottom
};

function mapParentsToPoints(fullDataset) {
  return fullDataset.map(function (d) {
    if (d.parentLine) {
      return _extends({}, d.parentLine, d);
    }
    if (d.parentArea) {
      return _extends({}, d.parentArea, d);
    }
    return d;
  });
}

var XYFrame = (_temp2 = _class = function (_React$Component) {
  _inherits(XYFrame, _React$Component);

  function XYFrame() {
    var _ref;

    var _temp, _this, _ret;

    _classCallCheck(this, XYFrame);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = XYFrame.__proto__ || Object.getPrototypeOf(XYFrame)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      size: [500, 500],
      dataVersion: undefined,
      lineData: undefined,
      pointData: undefined,
      areaData: undefined,
      projectedLines: undefined,
      projectedPoints: undefined,
      projectedAreas: undefined,
      fullDataset: [],
      adjustedPosition: [0, 0],
      adjustedSize: [500, 500],
      backgroundGraphics: null,
      foregroundGraphics: null,
      axesData: undefined,
      axes: undefined,
      axesTickLines: undefined,
      renderNumber: 0,
      margin: { top: 0, bottom: 0, left: 0, right: 0 },
      calculatedXExtent: [0, 0],
      calculatedYExtent: [0, 0],
      xAccessor: [function (d) {
        return d.x;
      }],
      yAccessor: [function (d) {
        return d.y;
      }],
      xExtent: [0, 0],
      yExtent: [0, 0],
      areaAnnotations: [],
      xScale: function xScale(d) {
        return d;
      },
      yScale: function yScale(d) {
        return d;
      },
      title: null,
      legendSettings: undefined,
      xyFrameRender: {},
      canvasDrawing: [],
      annotatedSettings: {},
      overlay: undefined
    }, _this.calculateXYFrame = function (currentProps, updateData) {
      var legend = currentProps.legend,
          lines = currentProps.lines,
          lineClass = currentProps.lineClass,
          pointStyle = currentProps.pointStyle,
          pointRenderMode = currentProps.pointRenderMode,
          pointClass = currentProps.pointClass,
          areaClass = currentProps.areaClass,
          canvasLines = currentProps.canvasLines,
          canvasPoints = currentProps.canvasPoints,
          canvasAreas = currentProps.canvasAreas,
          defined = currentProps.defined,
          size = currentProps.size,
          renderKey = currentProps.renderKey,
          _currentProps$lineTyp = currentProps.lineType,
          lineType = _currentProps$lineTyp === undefined ? { type: "line" } : _currentProps$lineTyp,
          _currentProps$areaTyp = currentProps.areaType,
          areaType = _currentProps$areaTyp === undefined ? { type: "basic" } : _currentProps$areaTyp,
          customLineMark = currentProps.customLineMark,
          customPointMark = currentProps.customPointMark,
          customAreaMark = currentProps.customAreaMark,
          areaStyle = currentProps.areaStyle,
          areaRenderMode = currentProps.areaRenderMode,
          lineStyle = currentProps.lineStyle,
          lineRenderMode = currentProps.lineRenderMode,
          baseXExtent = currentProps.xExtent,
          baseYExtent = currentProps.yExtent,
          title = currentProps.title,
          _currentProps$xScaleT = currentProps.xScaleType,
          xScaleType = _currentProps$xScaleT === undefined ? (0, _d3Scale.scaleLinear)() : _currentProps$xScaleT,
          _currentProps$yScaleT = currentProps.yScaleType,
          yScaleType = _currentProps$yScaleT === undefined ? (0, _d3Scale.scaleLinear)() : _currentProps$yScaleT,
          lineIDAccessor = currentProps.lineIDAccessor,
          invertX = currentProps.invertX,
          invertY = currentProps.invertY,
          showLinePoints = currentProps.showLinePoints,
          points = currentProps.points,
          areas = currentProps.areas,
          lineDataAccessor = currentProps.lineDataAccessor,
          areaDataAccessor = currentProps.areaDataAccessor,
          yAccessor = currentProps.yAccessor,
          xAccessor = currentProps.xAccessor,
          useAreasAsInteractionLayer = currentProps.useAreasAsInteractionLayer,
          baseMarkProps = currentProps.baseMarkProps;
      var projectedLines = currentProps.projectedLines,
          projectedPoints = currentProps.projectedPoints,
          projectedAreas = currentProps.projectedAreas,
          fullDataset = currentProps.fullDataset;


      var annotatedSettings = {
        xAccessor: (0, _dataFunctions.stringToArrayFn)(xAccessor, function (d) {
          return d[0];
        }),
        yAccessor: (0, _dataFunctions.stringToArrayFn)(yAccessor, function (d) {
          return d[1];
        }),
        areaDataAccessor: (0, _dataFunctions.stringToArrayFn)(areaDataAccessor, function (d) {
          return Array.isArray(d) ? d : d.coordinates;
        }),
        lineDataAccessor: (0, _dataFunctions.stringToArrayFn)(lineDataAccessor, function (d) {
          return Array.isArray(d) ? d : d.coordinates;
        }),
        lineType: (0, _frameFunctions.objectifyType)(lineType),
        areaType: (0, _frameFunctions.objectifyType)(areaType),
        lineIDAccessor: (0, _dataFunctions.stringToFn)(lineIDAccessor, function (l) {
          return l.semioticLineID;
        }),
        areas: !areas || Array.isArray(areas) && areas.length === 0 ? undefined : !Array.isArray(areas) ? [areas] : !areaDataAccessor && !areas[0].coordinates ? [{ coordinates: areas }] : areas,
        lines: !lines || Array.isArray(lines) && lines.length === 0 ? undefined : !Array.isArray(lines) ? [lines] : !lineDataAccessor && !lines[0].coordinates ? [{ coordinates: lines }] : lines,
        title: (typeof title === "undefined" ? "undefined" : _typeof(title)) === "object" && !_react2.default.isValidElement(title) && title !== null ? title : { title: title, orient: "top" },
        xExtent: baseXExtent && baseXExtent.extent || baseXExtent,
        yExtent: baseYExtent && baseYExtent.extent || baseYExtent
      };

      annotatedSettings.lineType.simpleLine = annotatedSettings.lineType.type === "line" && !annotatedSettings.lineType.y1 && annotatedSettings.lineType.simpleLine !== false;

      var margin = (0, _frameFunctions.calculateMargin)({
        margin: currentProps.margin,
        axes: currentProps.axes,
        title: annotatedSettings.title
      });

      var _adjustedPositionSize = (0, _frameFunctions.adjustedPositionSize)({
        size: currentProps.size,
        margin: margin,
        axes: currentProps.axes
      }),
          adjustedPosition = _adjustedPositionSize.adjustedPosition,
          adjustedSize = _adjustedPositionSize.adjustedSize;

      var calculatedXExtent = [],
          calculatedYExtent = [],
          yExtent = void 0,
          xExtent = void 0;

      var xExtentSettings = baseXExtent === undefined || Array.isArray(baseXExtent) ? { extent: baseXExtent } : baseXExtent;
      var yExtentSettings = baseYExtent === undefined || Array.isArray(baseYExtent) ? { extent: baseYExtent } : baseYExtent;

      var xScale = void 0,
          yScale = void 0;

      if (updateData || currentProps.dataVersion && currentProps.dataVersion !== _this.state.dataVersion) {
        if (!xExtent || !yExtent || !fullDataset || !projectedLines && !projectedPoints && !projectedAreas) {
          ;
          var _calculateDataExtent = (0, _dataFunctions.calculateDataExtent)({
            lineDataAccessor: annotatedSettings.lineDataAccessor,
            areaDataAccessor: annotatedSettings.areaDataAccessor,
            xAccessor: annotatedSettings.xAccessor,
            yAccessor: annotatedSettings.yAccessor,
            lineType: annotatedSettings.lineType,
            areaType: annotatedSettings.areaType,
            areas: annotatedSettings.areas,
            points: points,
            lines: annotatedSettings.lines,
            showLinePoints: showLinePoints,
            xExtent: baseXExtent,
            yExtent: baseYExtent,
            invertX: invertX,
            invertY: invertY,
            adjustedSize: size,
            xScaleType: xScaleType,
            yScaleType: yScaleType,
            defined: defined
          });

          xExtent = _calculateDataExtent.xExtent;
          yExtent = _calculateDataExtent.yExtent;
          projectedLines = _calculateDataExtent.projectedLines;
          projectedPoints = _calculateDataExtent.projectedPoints;
          projectedAreas = _calculateDataExtent.projectedAreas;
          fullDataset = _calculateDataExtent.fullDataset;
          calculatedXExtent = _calculateDataExtent.calculatedXExtent;
          calculatedYExtent = _calculateDataExtent.calculatedYExtent;
        }

        ;
        var _this$screenScales = _this.screenScales({
          xExtent: xExtent,
          yExtent: yExtent,
          adjustedSize: adjustedSize,
          xScaleType: xScaleType,
          yScaleType: yScaleType
        });

        xScale = _this$screenScales.xScale;
        yScale = _this$screenScales.yScale;
      } else {
        ;var _this$state = _this.state;
        xExtent = _this$state.xExtent;
        yExtent = _this$state.yExtent;
        projectedLines = _this$state.projectedLines;
        projectedPoints = _this$state.projectedPoints;
        projectedAreas = _this$state.projectedAreas;
        fullDataset = _this$state.fullDataset;
        calculatedXExtent = _this$state.calculatedXExtent;
        calculatedYExtent = _this$state.calculatedYExtent;

        if (adjustedSize[0] === _this.state.adjustedSize[0] && adjustedSize[1] === _this.state.adjustedSize[1]) {
          xScale = _this.state.xScale;
          yScale = _this.state.yScale;
        } else {
          ;
          var _this$screenScales2 = _this.screenScales({
            xExtent: xExtent,
            yExtent: yExtent,
            adjustedSize: adjustedSize,
            xScaleType: xScaleType,
            yScaleType: yScaleType
          });

          xScale = _this$screenScales2.xScale;
          yScale = _this$screenScales2.yScale;
        }
      }

      xExtent = xExtentSettings.extent || xExtent;
      yExtent = yExtentSettings.extent || yExtent;

      var canvasDrawing = [];

      var axes = void 0;
      var axesTickLines = void 0;

      var existingBaselines = {};

      if (currentProps.axes) {
        axesTickLines = [];
        axes = currentProps.axes.map(function (d, i) {
          var axisClassname = d.className || "";
          axisClassname += " axis";
          var axisScale = yScale;
          if (existingBaselines[d.orient]) {
            d.baseline = d.baseline || false;
          }
          existingBaselines[d.orient] = true;
          if (d.orient === "top" || d.orient === "bottom") {
            axisClassname += " x";
            axisScale = xScale;
          } else {
            axisClassname += " y";
          }
          axisClassname += " " + d.orient;

          var tickValues = void 0;
          if (d.tickValues && Array.isArray(d.tickValues)) {
            tickValues = d.tickValues;
          } else if (d.tickValues) {
            //otherwise assume a function
            tickValues = d.tickValues(fullDataset, currentProps.size, axisScale);
          }
          var axisSize = [adjustedSize[0], adjustedSize[1]];

          var axisParts = (0, _axis.axisPieces)({
            padding: d.padding,
            tickValues: tickValues,
            scale: axisScale,
            ticks: d.ticks,
            orient: d.orient,
            size: axisSize,
            margin: margin,
            footer: d.footer,
            tickSize: d.tickSize
          });
          var axisTickLines = _react2.default.createElement(
            "g",
            { key: "axes-tick-lines-" + i, className: "axis " + axisClassname },
            (0, _axis.axisLines)({
              axisParts: axisParts,
              orient: d.orient,
              tickLineGenerator: d.tickLineGenerator,
              baseMarkProps: baseMarkProps
            })
          );
          axesTickLines.push(axisTickLines);
          return _react2.default.createElement(_Axis2.default, {
            label: d.label,
            axisParts: axisParts,
            key: d.key || "axis-" + i,
            orient: d.orient,
            size: axisSize,
            margin: margin,
            ticks: d.ticks,
            tickSize: d.tickSize,
            tickFormat: d.tickFormat,
            tickValues: tickValues,
            format: d.format,
            scale: axisScale,
            className: axisClassname,
            name: d.name,
            padding: d.padding,
            rotate: d.rotate,
            annotationFunction: d.axisAnnotationFunction,
            glyphFunction: d.glyphFunction,
            baseline: d.baseline
          });
        });
      }
      var legendSettings = void 0;

      if (legend) {
        legendSettings = legend === true ? {} : legend;
        if (projectedLines && !legendSettings.legendGroups) {
          var typeString = annotatedSettings.lineType.type;
          var type = ["stackedarea", "stackedpercent", "bumparea"].indexOf(typeString) === -1 ? "line" : "fill";
          var legendGroups = [{
            styleFn: currentProps.lineStyle,
            type: type,
            items: projectedLines.map(function (d) {
              return _extends({ label: annotatedSettings.lineIDAccessor(d) }, d);
            })
          }];
          legendSettings.legendGroups = legendGroups;
        }
      }
      var areaAnnotations = [];

      if (annotatedSettings.areaType.label && projectedAreas) {
        projectedAreas.forEach(function (d, i) {
          if (d.bounds) {
            var bounds = Array.isArray(d.bounds) ? d.bounds : [d.bounds];
            bounds.forEach(function (labelBounds) {
              var label = typeof annotatedSettings.areaType.label === "function" ? annotatedSettings.areaType.label(d) : annotatedSettings.areaType.label;
              if (label && label !== null) {
                var labelPosition = label.position || "center";
                var labelCenter = [xScale(labelBounds[labelPosition][0]), yScale(labelBounds[labelPosition][1])] || [xScale(d._xyfCoordinates[0]), yScale(d._xyfCoordinates[1])];
                var labelContent = label.content || function (p) {
                  return p.value || p.id || i;
                };

                areaAnnotations.push({
                  x: labelCenter[0],
                  y: labelCenter[1],
                  dx: label.dx,
                  dy: label.dy,
                  className: label.className,
                  type: label.type || _AnnotationCallout2.default,
                  note: label.note || { title: labelContent(d) },
                  subject: label.subject || { text: labelContent(d) },
                  connector: label.connector
                });
              }
            });
          }
        });
      }

      var lineAriaLabel = annotatedSettings.lineType.type !== undefined && typeof annotatedSettings.lineType.type !== "function" && naturalLanguageLineType[annotatedSettings.lineType.type];

      var xyFrameRender = {
        lines: {
          accessibleTransform: function accessibleTransform(data, i) {
            return _extends({}, data[i].data[data[i].data.length - 1], {
              type: "frame-hover"
            });
          },
          data: projectedLines,
          styleFn: (0, _dataFunctions.stringToFn)(lineStyle, emptyObjectReturnFunction, true),
          classFn: (0, _dataFunctions.stringToFn)(lineClass, emptyStringReturnFunction, true),
          renderMode: (0, _dataFunctions.stringToFn)(lineRenderMode, undefined, true),
          canvasRender: (0, _dataFunctions.stringToFn)(canvasLines, undefined, true),
          customMark: customLineMark,
          type: annotatedSettings.lineType,
          defined: defined,
          renderKeyFn: (0, _dataFunctions.stringToFn)(renderKey, function (d, i) {
            return "line-" + i;
          }, true),
          ariaLabel: lineAriaLabel,
          axesData: currentProps.axes,
          behavior: _general.createLines
        },
        areas: {
          accessibleTransform: function accessibleTransform(data, i) {
            return _extends({}, data[i], { type: "frame-hover" });
          },
          data: projectedAreas,
          styleFn: (0, _dataFunctions.stringToFn)(areaStyle, emptyObjectReturnFunction, true),
          classFn: (0, _dataFunctions.stringToFn)(areaClass, emptyStringReturnFunction, true),
          renderMode: (0, _dataFunctions.stringToFn)(areaRenderMode, undefined, true),
          canvasRender: (0, _dataFunctions.stringToFn)(canvasAreas, undefined, true),
          customMark: customAreaMark,
          type: annotatedSettings.areaType,
          renderKeyFn: (0, _dataFunctions.stringToFn)(renderKey, function (d, i) {
            return "area-" + i;
          }, true),
          behavior: _general.createAreas
        },
        points: {
          accessibleTransform: function accessibleTransform(data, i) {
            return _extends({
              type: "frame-hover"
            }, data[i].data || data[i]);
          },
          data: projectedPoints,
          styleFn: (0, _dataFunctions.stringToFn)(pointStyle, emptyObjectReturnFunction, true),
          classFn: (0, _dataFunctions.stringToFn)(pointClass, emptyStringReturnFunction, true),
          renderMode: (0, _dataFunctions.stringToFn)(pointRenderMode, undefined, true),
          canvasRender: (0, _dataFunctions.stringToFn)(canvasPoints, undefined, true),
          customMark: customPointMark,
          renderKeyFn: (0, _dataFunctions.stringToFn)(renderKey, function (d, i) {
            return "point-" + i;
          }, true),
          behavior: _general.createPoints
        }
      };

      if (xExtentSettings.onChange && _this.state.calculatedXExtent.join(",") !== calculatedXExtent.join(",")) {
        xExtentSettings.onChange(calculatedXExtent);
      }
      if (yExtentSettings.onChange && _this.state.calculatedYExtent.join(",") !== calculatedYExtent.join(",")) {
        yExtentSettings.onChange(calculatedYExtent);
      }

      var overlay = undefined;
      if (useAreasAsInteractionLayer && projectedAreas) {
        overlay = (0, _general.createAreas)({ xScale: xScale, yScale: yScale, data: projectedAreas }).map(function (m, i) {
          return _extends({}, m.props, {
            style: { fillOpacity: 0 },
            overlayData: projectedAreas && projectedAreas[i] // luckily createAreas is a map fn
          });
        });
      }

      _this.setState({
        lineData: currentProps.lines,
        pointData: currentProps.points,
        areaData: currentProps.areas,
        dataVersion: currentProps.dataVersion,
        projectedLines: projectedLines,
        projectedPoints: projectedPoints,
        projectedAreas: projectedAreas,
        canvasDrawing: canvasDrawing,
        fullDataset: fullDataset,
        adjustedPosition: adjustedPosition,
        adjustedSize: adjustedSize,
        backgroundGraphics: currentProps.backgroundGraphics,
        foregroundGraphics: currentProps.foregroundGraphics,
        axesData: currentProps.axes,
        axes: axes,
        axesTickLines: axesTickLines,
        renderNumber: _this.state.renderNumber + 1,
        xScale: xScale,
        yScale: yScale,
        xAccessor: annotatedSettings.xAccessor,
        yAccessor: annotatedSettings.yAccessor,
        xExtent: [xExtent[0] === undefined ? calculatedXExtent[0] : xExtent[0], xExtent[1] === undefined ? calculatedXExtent[1] : xExtent[1]],
        yExtent: [yExtent[0] === undefined ? calculatedYExtent[0] : yExtent[0], yExtent[1] === undefined ? calculatedYExtent[1] : yExtent[1]],
        calculatedXExtent: calculatedXExtent,
        calculatedYExtent: calculatedYExtent,
        margin: margin,
        legendSettings: legendSettings,
        areaAnnotations: areaAnnotations,
        xyFrameRender: xyFrameRender,
        size: size,
        annotatedSettings: annotatedSettings,
        overlay: overlay
      });
    }, _this.defaultXYSVGRule = function (_ref2) {
      var baseD = _ref2.d,
          i = _ref2.i,
          annotationLayer = _ref2.annotationLayer,
          lines = _ref2.lines,
          areas = _ref2.areas,
          points = _ref2.points;

      var xAccessor = _this.state.xAccessor;
      var yAccessor = _this.state.yAccessor;

      var xScale = _this.state.xScale;
      var yScale = _this.state.yScale;

      var screenCoordinates = [];
      var idAccessor = _this.state.annotatedSettings.lineIDAccessor;
      var d = baseD.coordinates ? baseD : (0, _lineDrawing.findPointByID)({
        point: baseD,
        idAccessor: idAccessor,
        lines: lines,
        xScale: xScale,
        projectedX: _coordinateNames.projectedX,
        xAccessor: xAccessor
      });

      if (!d) return null;

      var margin = (0, _frameFunctions.calculateMargin)({
        margin: _this.props.margin,
        axes: _this.props.axes,
        title: _this.state.annotatedSettings.title
      });

      var _adjustedPositionSize2 = (0, _frameFunctions.adjustedPositionSize)({
        size: _this.props.size,
        margin: margin,
        axes: _this.props.axes,
        title: _this.props.title
      }),
          adjustedPosition = _adjustedPositionSize2.adjustedPosition,
          adjustedSize = _adjustedPositionSize2.adjustedSize;

      if (!d.coordinates && !d.bounds) {
        screenCoordinates = [(0, _lineDrawing.relativeX)({
          point: d,
          projectedXMiddle: _coordinateNames.projectedXMiddle,
          projectedX: _coordinateNames.projectedX,
          xAccessor: xAccessor,
          xScale: xScale
        }), (0, _lineDrawing.relativeY)({
          point: d,
          projectedYMiddle: _coordinateNames.projectedYMiddle,
          projectedY: _coordinateNames.projectedY,
          yAccessor: yAccessor,
          yScale: yScale
        })];

        if (d.type !== "highlight" && (screenCoordinates[0] === undefined || screenCoordinates[1] === undefined || screenCoordinates[0] === null || screenCoordinates[1] === null)) {
          //NO ANNOTATION IF INVALID SCREEN COORDINATES
          return null;
        }
      } else if (!d.bounds) {
        screenCoordinates = d.coordinates.reduce(function (coords, p) {
          var xCoordinate = (0, _lineDrawing.relativeX)({
            point: p,
            projectedXMiddle: _coordinateNames.projectedXMiddle,
            projectedX: _coordinateNames.projectedX,
            xAccessor: xAccessor,
            xScale: xScale
          });

          var yCoordinate = (0, _lineDrawing.relativeY)({
            point: p,
            lines: lines,
            projectedYMiddle: _coordinateNames.projectedYMiddle,
            projectedY: _coordinateNames.projectedY,
            projectedX: _coordinateNames.projectedX,
            xAccessor: xAccessor,
            yAccessor: yAccessor,
            yScale: yScale,
            xScale: xScale,
            idAccessor: idAccessor
          });
          if (Array.isArray(yCoordinate)) {
            return [].concat(_toConsumableArray(coords), [[xCoordinate, Math.min.apply(Math, _toConsumableArray(yCoordinate))], [xCoordinate, Math.max.apply(Math, _toConsumableArray(yCoordinate))]]);
          } else if (Array.isArray(xCoordinate)) {
            return [].concat(_toConsumableArray(coords), [[Math.min.apply(Math, _toConsumableArray(xCoordinate)), yCoordinate], [Math.max.apply(Math, _toConsumableArray(xCoordinate)), yCoordinate]]);
          } else {
            return [].concat(_toConsumableArray(coords), [[xCoordinate, yCoordinate]]);
          }
        }, []);
      }

      var customSVG = _this.props.svgAnnotationRules && _this.props.svgAnnotationRules({
        d: d,
        i: i,
        screenCoordinates: screenCoordinates,
        xScale: xScale,
        yScale: yScale,
        xAccessor: xAccessor,
        yAccessor: yAccessor,
        xyFrameProps: _this.props,
        xyFrameState: _this.state,
        areas: areas,
        points: points,
        lines: lines
      });
      if (_this.props.svgAnnotationRules !== undefined && customSVG !== null) {
        return customSVG;
      } else if (d.type === "xy" || d.type === "frame-hover") {
        return (0, _xyframeRules.svgXYAnnotation)({ d: d, i: i, screenCoordinates: screenCoordinates });
      } else if (d.type === "highlight") {
        return (0, _xyframeRules.svgHighlight)({
          d: d,
          screenCoordinates: screenCoordinates,
          i: i,
          idAccessor: idAccessor,
          lines: lines,
          areas: areas,
          points: points,
          xScale: xScale,
          yScale: yScale
        });
      } else if (d.type === "react-annotation" || typeof d.type === "function") {
        return (0, _xyframeRules.basicReactAnnotation)({ d: d, screenCoordinates: screenCoordinates, i: i });
      } else if (d.type === "enclose") {
        return (0, _xyframeRules.svgEncloseAnnotation)({ d: d, screenCoordinates: screenCoordinates, i: i });
      } else if (d.type === "enclose-rect") {
        return (0, _xyframeRules.svgRectEncloseAnnotation)({ d: d, screenCoordinates: screenCoordinates, i: i });
      } else if (d.type === "enclose-hull") {
        return (0, _xyframeRules.svgHullEncloseAnnotation)({ d: d, screenCoordinates: screenCoordinates, i: i });
      } else if (d.type === "x") {
        return (0, _xyframeRules.svgXAnnotation)({
          d: d,
          screenCoordinates: screenCoordinates,
          i: i,
          annotationLayer: annotationLayer,
          adjustedSize: adjustedSize,
          margin: margin
        });
      } else if (d.type === "y") {
        return (0, _xyframeRules.svgYAnnotation)({
          d: d,
          screenCoordinates: screenCoordinates,
          i: i,
          annotationLayer: annotationLayer,
          adjustedSize: adjustedSize,
          adjustedPosition: adjustedPosition,
          margin: margin
        });
      } else if (d.type === "bounds") {
        return (0, _xyframeRules.svgBoundsAnnotation)({
          d: d,
          i: i,
          adjustedSize: adjustedSize,
          adjustedPosition: adjustedPosition,
          xAccessor: xAccessor,
          yAccessor: yAccessor,
          xScale: xScale,
          yScale: yScale,
          margin: margin
        });
      } else if (d.type === "line") {
        return (0, _xyframeRules.svgLineAnnotation)({ d: d, i: i, screenCoordinates: screenCoordinates });
      } else if (d.type === "area") {
        return (0, _xyframeRules.svgAreaAnnotation)({
          d: d,
          i: i,
          screenCoordinates: screenCoordinates,
          xScale: xScale,
          xAccessor: xAccessor,
          yScale: yScale,
          yAccessor: yAccessor,
          annotationLayer: annotationLayer
        });
      } else if (d.type === "horizontal-points") {
        return (0, _xyframeRules.svgHorizontalPointsAnnotation)({
          d: d,
          lines: lines.data,
          points: points.data,
          xScale: xScale,
          yScale: yScale,
          pointStyle: points.styleFn
        });
      } else if (d.type === "vertical-points") {
        return (0, _xyframeRules.svgVerticalPointsAnnotation)({
          d: d,
          lines: lines.data,
          points: points.data,
          xScale: xScale,
          yScale: yScale,
          pointStyle: points.styleFn
        });
      }
      return null;
    }, _this.defaultXYHTMLRule = function (_ref3) {
      var baseD = _ref3.d,
          i = _ref3.i,
          lines = _ref3.lines,
          areas = _ref3.areas,
          points = _ref3.points;

      var xAccessor = _this.state.xAccessor;
      var yAccessor = _this.state.yAccessor;

      var xScale = _this.state.xScale;
      var yScale = _this.state.yScale;

      var screenCoordinates = [];

      var _this$props = _this.props,
          size = _this$props.size,
          useSpans = _this$props.useSpans;


      var idAccessor = _this.state.annotatedSettings.lineIDAccessor;
      var d = (0, _lineDrawing.findPointByID)({
        point: baseD,
        idAccessor: idAccessor,
        lines: lines,
        xScale: xScale,
        projectedX: _coordinateNames.projectedX,
        xAccessor: xAccessor
      });

      if (!d) {
        return null;
      }

      var xCoord = d[_coordinateNames.projectedXMiddle] || d[_coordinateNames.projectedX] || (0, _multiAccessorUtils.findFirstAccessorValue)(xAccessor, d);
      var yCoord = d[_coordinateNames.projectedYMiddle] || d[_coordinateNames.projectedY] || (0, _multiAccessorUtils.findFirstAccessorValue)(yAccessor, d);

      var xString = xCoord && xCoord.toString ? xCoord.toString() : xCoord;
      var yString = yCoord && yCoord.toString ? yCoord.toString() : yCoord;

      var margin = (0, _frameFunctions.calculateMargin)({
        margin: _this.props.margin,
        axes: _this.props.axes,
        title: _this.state.annotatedSettings.title
      });

      var _adjustedPositionSize3 = (0, _frameFunctions.adjustedPositionSize)({
        size: _this.props.size,
        margin: margin,
        axes: _this.props.axes,
        title: _this.props.title
      }),
          adjustedPosition = _adjustedPositionSize3.adjustedPosition;

      if (!d.coordinates) {
        screenCoordinates = [xScale(xCoord), (0, _lineDrawing.relativeY)({
          point: d,
          lines: lines,
          projectedYMiddle: _coordinateNames.projectedYMiddle,
          projectedY: _coordinateNames.projectedY,
          projectedX: _coordinateNames.projectedX,
          xAccessor: xAccessor,
          yAccessor: yAccessor,
          yScale: yScale,
          xScale: xScale,
          idAccessor: idAccessor
        })];
        if (screenCoordinates[0] === undefined || screenCoordinates[1] === undefined || screenCoordinates[0] === null || screenCoordinates[1] === null) {
          //NO ANNOTATION IF INVALID SCREEN COORDINATES
          return null;
        }
      } else {
        screenCoordinates = d.coordinates.map(function (p) {
          var foundP = (0, _lineDrawing.findPointByID)({
            point: p,
            idAccessor: idAccessor,
            lines: lines,
            xScale: xScale,
            projectedX: _coordinateNames.projectedX,
            xAccessor: xAccessor
          });
          return [xScale((0, _multiAccessorUtils.findFirstAccessorValue)(xAccessor, d)) + adjustedPosition[0], (0, _lineDrawing.relativeY)({
            point: foundP,
            lines: lines,
            projectedYMiddle: _coordinateNames.projectedYMiddle,
            projectedY: _coordinateNames.projectedY,
            projectedX: _coordinateNames.projectedX,
            xAccessor: xAccessor,
            yAccessor: yAccessor,
            yScale: yScale,
            xScale: xScale,
            idAccessor: idAccessor
          }) + adjustedPosition[1]];
        });
      }

      if (_this.props.htmlAnnotationRules && _this.props.htmlAnnotationRules({
        d: d,
        i: i,
        screenCoordinates: screenCoordinates,
        xScale: xScale,
        yScale: yScale,
        xAccessor: xAccessor,
        yAccessor: yAccessor,
        xyFrameProps: _this.props,
        xyFrameState: _this.state,
        areas: areas,
        points: points,
        lines: lines
      }) !== null) {
        return _this.props.htmlAnnotationRules({
          d: d,
          i: i,
          screenCoordinates: screenCoordinates,
          xScale: xScale,
          yScale: yScale,
          xAccessor: xAccessor,
          yAccessor: yAccessor,
          xyFrameProps: _this.props,
          xyFrameState: _this.state,
          areas: areas,
          points: points,
          lines: lines
        });
      }
      if (d.type === "frame-hover") {
        var content = _react2.default.createElement(
          _SpanOrDiv2.default,
          { span: useSpans, className: "tooltip-content" },
          _react2.default.createElement(
            "p",
            { key: "html-annotation-content-1" },
            xString
          ),
          _react2.default.createElement(
            "p",
            { key: "html-annotation-content-2" },
            yString
          ),
          d.percent ? _react2.default.createElement(
            "p",
            { key: "html-annotation-content-3" },
            parseInt(d.percent * 1000, 10) / 10,
            "%"
          ) : null
        );

        if (d.type === "frame-hover" && _this.props.tooltipContent) {
          content = _this.props.tooltipContent(d);
        }
        return (0, _xyframeRules.htmlTooltipAnnotation)({
          content: content,
          screenCoordinates: screenCoordinates,
          size: size,
          i: i,
          d: d,
          useSpans: useSpans
        });
      }
      return null;
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  _createClass(XYFrame, [{
    key: "componentWillMount",
    value: function componentWillMount() {
      Object.keys(this.props).forEach(function (d) {
        if (!_frame_props.xyframeproptypes[d]) {
          if (_frame_props.ordinalframeproptypes[d]) {
            console.error(d + " is an OrdinalFrame prop are you sure you're using the right frame?");
          } else if (_frame_props.networkframeproptypes[d]) {
            console.error(d + " is a NetworkFrame prop are you sure you're using the right frame?");
          } else {
            console.error(d + " is not a valid XYFrame prop");
          }
        }
      });
      this.calculateXYFrame(this.props, true);
    }
  }, {
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(nextProps) {
      var _this2 = this;

      var _state = this.state,
          _state$xExtent = _state.xExtent,
          oldXExtent = _state$xExtent === undefined ? [] : _state$xExtent,
          _state$yExtent = _state.yExtent,
          oldYExtent = _state$yExtent === undefined ? [] : _state$yExtent,
          oldSize = _state.size,
          oldDataVersion = _state.dataVersion,
          lineData = _state.lineData,
          areaData = _state.areaData;
      var baseNewXExtent = nextProps.xExtent,
          baseNewYExtent = nextProps.yExtent,
          newSize = nextProps.size,
          newDataVersion = nextProps.dataVersion,
          newLines = nextProps.lines,
          newAreas = nextProps.areas;


      var newXExtent = (0, _unflowedFunctions.extentValue)(baseNewXExtent);

      var newYExtent = (0, _unflowedFunctions.extentValue)(baseNewYExtent);

      var extentChange = oldXExtent[0] !== newXExtent[0] && newXExtent[0] !== undefined || oldYExtent[0] !== newYExtent[0] && newYExtent[0] !== undefined || oldXExtent[1] !== newXExtent[1] && newXExtent[1] !== undefined || oldYExtent[1] !== newYExtent[1] && newYExtent[1] !== undefined;

      var lineChange = lineData !== newLines || Array.isArray(lineData) && Array.isArray(newLines) && !!lineData.find(function (p) {
        return newLines.indexOf(p) === -1;
      });

      var areaChange = areaData !== newAreas || Array.isArray(areaData) && Array.isArray(newAreas) && !!areaData.find(function (p) {
        return newAreas.indexOf(p) === -1;
      });

      if (oldDataVersion && oldDataVersion !== newDataVersion || !this.state.fullDataset) {
        this.calculateXYFrame(nextProps, true);
      } else if (lineChange || areaChange || oldSize[0] !== newSize[0] || oldSize[1] !== newSize[1] || extentChange || !oldDataVersion && _frame_props.xyFrameChangeProps.find(function (d) {
        return _this2.props[d] !== nextProps[d];
      })) {
        var dataChanged = lineChange || areaChange || extentChange || !!_frame_props.xyFrameDataProps.find(function (d) {
          return _this2.props[d] !== nextProps[d];
        });

        this.calculateXYFrame(nextProps, dataChanged);
      }
    }
  }, {
    key: "screenScales",
    value: function screenScales(_ref4) {
      var xExtent = _ref4.xExtent,
          yExtent = _ref4.yExtent,
          adjustedSize = _ref4.adjustedSize,
          xScaleType = _ref4.xScaleType,
          yScaleType = _ref4.yScaleType;

      var xDomain = [0, adjustedSize[0]];
      var yDomain = [adjustedSize[1], 0];

      var xScale = xScaleType;
      var yScale = yScaleType;

      if (xScaleType.domain) {
        xScaleType.domain(xExtent);
      }
      if (yScaleType.domain) {
        yScaleType.domain(yExtent);
      }
      xScaleType.range(xDomain);
      yScaleType.range(yDomain);

      return { xScale: xScale, yScale: yScale };
    }
  }, {
    key: "render",
    value: function render() {
      var _props = this.props,
          downloadFields = _props.downloadFields,
          xAccessor = _props.xAccessor,
          yAccessor = _props.yAccessor,
          lines = _props.lines,
          points = _props.points,
          areas = _props.areas,
          name = _props.name,
          download = _props.download,
          size = _props.size,
          className = _props.className,
          annotationSettings = _props.annotationSettings,
          annotations = _props.annotations,
          additionalDefs = _props.additionalDefs,
          hoverAnnotation = _props.hoverAnnotation,
          interaction = _props.interaction,
          customClickBehavior = _props.customClickBehavior,
          customHoverBehavior = _props.customHoverBehavior,
          customDoubleClickBehavior = _props.customDoubleClickBehavior,
          canvasPostProcess = _props.canvasPostProcess,
          baseMarkProps = _props.baseMarkProps,
          useSpans = _props.useSpans,
          canvasAreas = _props.canvasAreas,
          canvasPoints = _props.canvasPoints,
          canvasLines = _props.canvasLines,
          afterElements = _props.afterElements,
          beforeElements = _props.beforeElements,
          renderOrder = _props.renderOrder,
          matte = _props.matte,
          frameKey = _props.frameKey;
      var _state2 = this.state,
          backgroundGraphics = _state2.backgroundGraphics,
          foregroundGraphics = _state2.foregroundGraphics,
          adjustedPosition = _state2.adjustedPosition,
          adjustedSize = _state2.adjustedSize,
          margin = _state2.margin,
          axes = _state2.axes,
          axesTickLines = _state2.axesTickLines,
          xScale = _state2.xScale,
          yScale = _state2.yScale,
          dataVersion = _state2.dataVersion,
          fullDataset = _state2.fullDataset,
          areaAnnotations = _state2.areaAnnotations,
          legendSettings = _state2.legendSettings,
          xyFrameRender = _state2.xyFrameRender,
          annotatedSettings = _state2.annotatedSettings,
          overlay = _state2.overlay;


      var downloadButton = void 0;
      if (download && (points || lines)) {
        var downloadData = download === "points" ? mapParentsToPoints(fullDataset) : points || lines || areas;
        downloadButton = _react2.default.createElement(_DownloadButton2.default, {
          csvName: name + "-" + new Date().toJSON(),
          width: parseInt(size[0], 10),
          data: (0, _downloadDataMapping.xyDownloadMapping)({
            data: downloadData,
            xAccessor: download === "points" || points ? (0, _dataFunctions.stringToArrayFn)(xAccessor) : undefined,
            yAccessor: download === "points" || points ? (0, _dataFunctions.stringToArrayFn)(yAccessor) : undefined,
            fields: downloadFields
          })
        });
      }

      return _react2.default.createElement(_Frame2.default, {
        name: "xyframe",
        renderPipeline: xyFrameRender,
        adjustedPosition: adjustedPosition,
        size: size,
        projectedCoordinateNames: projectedCoordinateNames,
        xScale: xScale,
        yScale: yScale,
        axes: axes,
        axesTickLines: axesTickLines,
        title: annotatedSettings.title,
        dataVersion: dataVersion,
        matte: matte,
        className: className,
        adjustedSize: adjustedSize,
        frameKey: frameKey || xyframeKey,
        additionalDefs: additionalDefs,
        hoverAnnotation: hoverAnnotation,
        defaultSVGRule: this.defaultXYSVGRule,
        defaultHTMLRule: this.defaultXYHTMLRule,
        annotations: areaAnnotations.length > 0 ? [].concat(_toConsumableArray(annotations), _toConsumableArray(areaAnnotations)) : annotations,
        annotationSettings: annotationSettings,
        legendSettings: legendSettings,
        projectedYMiddle: _coordinateNames.projectedYMiddle,
        interaction: interaction,
        customClickBehavior: customClickBehavior,
        customHoverBehavior: customHoverBehavior,
        customDoubleClickBehavior: customDoubleClickBehavior,
        points: fullDataset,
        margin: margin,
        backgroundGraphics: backgroundGraphics,
        foregroundGraphics: foregroundGraphics,
        beforeElements: beforeElements,
        afterElements: afterElements,
        downloadButton: downloadButton,
        disableContext: this.props.disableContext,
        canvasPostProcess: canvasPostProcess,
        baseMarkProps: baseMarkProps,
        useSpans: useSpans,
        canvasRendering: !!(canvasAreas || canvasPoints || canvasLines),
        renderOrder: renderOrder,
        overlay: overlay
      });
    }
  }]);

  return XYFrame;
}(_react2.default.Component), _class.defaultProps = {
  annotations: [],
  foregroundGraphics: undefined,
  size: [500, 500],
  className: "",
  lineType: "line",
  name: "xyframe",
  dataVersion: undefined
}, _class.displayName = "XYFrame", _temp2);
exports.default = XYFrame;
module.exports = exports['default'];