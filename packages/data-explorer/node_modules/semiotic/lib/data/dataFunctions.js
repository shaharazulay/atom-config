"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.calculateDataExtent = exports.stringToArrayFn = exports.stringToFn = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _lineDrawing = require("../svg/lineDrawing");

var _coordinateNames = require("../constants/coordinateNames");

var _areaDrawing = require("../svg/areaDrawing");

var _d3Array = require("d3-array");

var _unflowedFunctions = require("./unflowedFunctions");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var builtInTransformations = {
  "stackedarea": _lineDrawing.stackedArea,
  "stackedarea-invert": _lineDrawing.stackedArea,
  "stackedpercent": _lineDrawing.stackedArea,
  "stackedpercent-invert": _lineDrawing.stackedArea,
  "linepercent": _lineDrawing.stackedArea,
  "difference": _lineDrawing.differenceLine,
  "bumparea": _lineDrawing.bumpChart,
  "bumpline": _lineDrawing.bumpChart,
  "bumparea-invert": _lineDrawing.bumpChart,
  "line": _lineDrawing.lineChart,
  "cumulative": _lineDrawing.cumulativeLine,
  "cumulative-reverse": _lineDrawing.cumulativeLine
};

var stringToFn = exports.stringToFn = function stringToFn(accessor, defaultAccessor, raw) {
  if (!accessor && defaultAccessor) {
    return defaultAccessor;
  } else if (typeof accessor !== "function" && raw !== undefined) {
    return function () {
      return accessor;
    };
  }

  return typeof accessor !== "function" ? function (d) {
    return d[accessor];
  } : accessor;
};

var stringToArrayFn = exports.stringToArrayFn = function stringToArrayFn(accessor, defaultAccessor, raw) {
  if (!accessor) {
    return [stringToFn(accessor, defaultAccessor, raw)];
  }
  var arrayOfAccessors = Array.isArray(accessor) ? accessor : [accessor];

  return arrayOfAccessors.map(function (a) {
    return stringToFn(a, defaultAccessor, raw);
  });
};

var calculateDataExtent = exports.calculateDataExtent = function calculateDataExtent(_ref) {
  var lineDataAccessor = _ref.lineDataAccessor,
      xAccessor = _ref.xAccessor,
      yAccessor = _ref.yAccessor,
      areas = _ref.areas,
      points = _ref.points,
      lines = _ref.lines,
      lineType = _ref.lineType,
      showLinePoints = _ref.showLinePoints,
      xExtent = _ref.xExtent,
      yExtent = _ref.yExtent,
      invertX = _ref.invertX,
      invertY = _ref.invertY,
      areaDataAccessor = _ref.areaDataAccessor,
      areaType = _ref.areaType,
      size = _ref.adjustedSize,
      xScaleType = _ref.xScaleType,
      yScaleType = _ref.yScaleType,
      _ref$defined = _ref.defined,
      defined = _ref$defined === undefined ? function () {
    return true;
  } : _ref$defined;

  var fullDataset = [];
  var initialProjectedLines = [];

  var projectedPoints = [],
      projectedLines = [],
      projectedAreas = [];
  if (points) {
    xAccessor.forEach(function (actualXAccessor) {
      yAccessor.forEach(function (actualYAccessor) {
        points.forEach(function (d, i) {
          var x = actualXAccessor(d, i);
          var y = actualYAccessor(d, i);
          var projectedPoint = { x: x, y: y, data: d };
          if (Array.isArray(y)) {
            projectedPoint[_coordinateNames.projectedYBottom] = Math.min.apply(Math, _toConsumableArray(y));
            projectedPoint[_coordinateNames.projectedYTop] = Math.max.apply(Math, _toConsumableArray(y));
            projectedPoint[_coordinateNames.projectedYMiddle] = (projectedPoint[_coordinateNames.projectedYBottom] + projectedPoint[_coordinateNames.projectedYTop]) / 2;
          }
          if (Array.isArray(x)) {
            projectedPoint[_coordinateNames.projectedXBottom] = Math.min.apply(Math, _toConsumableArray(x));
            projectedPoint[_coordinateNames.projectedXTop] = Math.max.apply(Math, _toConsumableArray(x));
            projectedPoint[_coordinateNames.projectedXMiddle] = (projectedPoint[_coordinateNames.projectedXBottom] + projectedPoint[_coordinateNames.projectedXTop]) / 2;
          }
          projectedPoints.push(projectedPoint);
        });
      });
    });

    fullDataset = projectedPoints;
  }
  if (lines) {
    initialProjectedLines = (0, _lineDrawing.projectLineData)({
      data: lines,
      lineDataAccessor: lineDataAccessor,
      xProp: _coordinateNames.projectedX,
      yProp: _coordinateNames.projectedY,
      yPropTop: _coordinateNames.projectedYTop,
      yPropBottom: _coordinateNames.projectedYBottom,
      xAccessor: xAccessor,
      yAccessor: yAccessor
    });

    var optionsObject = {
      xProp: _coordinateNames.projectedX,
      yProp: _coordinateNames.projectedY,
      yPropMiddle: _coordinateNames.projectedYMiddle,
      yPropTop: _coordinateNames.projectedYTop,
      yPropBottom: _coordinateNames.projectedYBottom,
      xPropMiddle: _coordinateNames.projectedXMiddle,
      xPropTop: _coordinateNames.projectedXTop,
      xPropBottom: _coordinateNames.projectedXBottom
    };

    projectedLines = lineTransformation(lineType, optionsObject)(initialProjectedLines);

    projectedLines.forEach(function (d) {
      fullDataset = [].concat(_toConsumableArray(fullDataset), _toConsumableArray(d.data.filter(function (p, q) {
        return defined(_extends({}, p.data, p), q);
      }).map(function (p) {
        var mappedP = {
          parentLine: d,
          y: p.y,
          x: p.x,
          yTop: p.yTop,
          yMiddle: p.yMiddle,
          yBottom: p.yBottom,
          data: p.data
        };
        if (p.percent) {
          mappedP.percent = p.percent;
        }
        return mappedP;
      })));
    });
  }

  if (areas) {
    projectedAreas = (0, _lineDrawing.projectAreaData)({
      data: areas,
      areaDataAccessor: areaDataAccessor,
      xProp: _coordinateNames.projectedX,
      yProp: _coordinateNames.projectedY,
      yPropTop: _coordinateNames.projectedYTop,
      yPropBottom: _coordinateNames.projectedYBottom,
      xAccessor: xAccessor,
      yAccessor: yAccessor
    });

    projectedAreas.forEach(function (d) {
      var baseData = d._baseData;
      if (d._xyfCoordinates[0][0][0]) {
        d._xyfCoordinates[0].forEach(function (multi) {
          multi.map(function (p, q) {
            var _extends2;

            return _extends({ parentArea: d }, baseData[q], (_extends2 = {}, _defineProperty(_extends2, _coordinateNames.projectedX, p[0]), _defineProperty(_extends2, _coordinateNames.projectedY, p[1]), _extends2));
          }).forEach(function (e) {
            return fullDataset.push(e);
          });
        });
      } else {
        d._xyfCoordinates.map(function (p, q) {
          var _extends3;

          return _extends({ parentArea: d }, baseData[q], (_extends3 = {}, _defineProperty(_extends3, _coordinateNames.projectedX, p[0]), _defineProperty(_extends3, _coordinateNames.projectedY, p[1]), _extends3));
        }).forEach(function (e) {
          return fullDataset.push(e);
        });
      }
    });
  }

  if (showLinePoints) {
    projectedPoints = fullDataset.map(function (d) {
      return _extends({}, d, _defineProperty({}, _coordinateNames.projectedY, d[_coordinateNames.projectedYTop] || d[_coordinateNames.projectedYBottom] || d.y));
    });
  }

  var calculatedXExtent = [(0, _d3Array.min)(fullDataset.map(function (d) {
    return d[_coordinateNames.projectedXBottom] === undefined ? d[_coordinateNames.projectedX] : Math.min(d[_coordinateNames.projectedXTop], d[_coordinateNames.projectedXBottom]);
  })), (0, _d3Array.max)(fullDataset.map(function (d) {
    return d[_coordinateNames.projectedXTop] === undefined ? d[_coordinateNames.projectedX] : Math.max(d[_coordinateNames.projectedXBottom], d[_coordinateNames.projectedXTop]);
  }))];

  var calculatedYExtent = [(0, _d3Array.min)(fullDataset.map(function (d) {
    return d[_coordinateNames.projectedYBottom] === undefined ? d[_coordinateNames.projectedY] : Math.min(d[_coordinateNames.projectedYTop], d[_coordinateNames.projectedYBottom]);
  })), (0, _d3Array.max)(fullDataset.map(function (d) {
    return d[_coordinateNames.projectedYTop] === undefined ? d[_coordinateNames.projectedY] : Math.max(d[_coordinateNames.projectedYBottom], d[_coordinateNames.projectedYTop]);
  }))];

  var actualXExtent = (0, _unflowedFunctions.extentValue)(xExtent);
  var actualYExtent = (0, _unflowedFunctions.extentValue)(yExtent);

  var xMin = actualXExtent && actualXExtent[0] !== undefined ? actualXExtent[0] : calculatedXExtent[0];
  var xMax = actualXExtent && actualXExtent[1] !== undefined ? actualXExtent[1] : calculatedXExtent[1];

  var yMin = actualYExtent && actualYExtent[0] !== undefined ? actualYExtent[0] : calculatedYExtent[0];
  var yMax = actualYExtent && actualYExtent[1] !== undefined ? actualYExtent[1] : calculatedYExtent[1];

  var finalYExtent = [yMin, yMax];
  var finalXExtent = [xMin, xMax];

  if (invertX && !(actualXExtent && actualXExtent.length === 2)) {
    finalXExtent = [finalXExtent[1], finalXExtent[0]];
  }
  if (invertY && !(actualYExtent && actualYExtent.length === 2)) {
    finalYExtent = [finalYExtent[1], finalYExtent[0]];
  }

  if (areaType.type && areaType.type === "contour") {
    projectedAreas = (0, _areaDrawing.contouring)({
      areaType: areaType,
      data: projectedAreas,
      projectedX: _coordinateNames.projectedX,
      projectedY: _coordinateNames.projectedY,
      finalXExtent: finalXExtent,
      finalYExtent: finalYExtent
    });
  } else if (areaType.type && areaType.type === "hexbin") {
    projectedAreas = (0, _areaDrawing.hexbinning)({
      areaType: areaType,
      data: projectedAreas,
      projectedX: _coordinateNames.projectedX,
      projectedY: _coordinateNames.projectedY,
      finalXExtent: finalXExtent,
      finalYExtent: finalYExtent,
      size: size,
      xScaleType: xScaleType,
      yScaleType: yScaleType
    });
    fullDataset = [].concat(_toConsumableArray(projectedAreas.map(function (d) {
      return d.data;
    })), _toConsumableArray(fullDataset.filter(function (d) {
      return !d.parentArea;
    })));
  } else if (areaType.type && areaType.type === "heatmap") {
    projectedAreas = (0, _areaDrawing.heatmapping)({
      areaType: areaType,
      data: projectedAreas,
      projectedX: _coordinateNames.projectedX,
      projectedY: _coordinateNames.projectedY,
      finalXExtent: finalXExtent,
      finalYExtent: finalYExtent,
      size: size,
      xScaleType: xScaleType,
      yScaleType: yScaleType
    });

    fullDataset = [].concat(_toConsumableArray(projectedAreas.map(function (d) {
      return _extends({}, d);
    })), _toConsumableArray(fullDataset.filter(function (d) {
      return !d.parentArea;
    })));
  }

  return {
    xExtent: finalXExtent,
    yExtent: finalYExtent,
    projectedLines: projectedLines,
    projectedPoints: projectedPoints,
    projectedAreas: projectedAreas,
    fullDataset: fullDataset,
    calculatedXExtent: calculatedXExtent,
    calculatedYExtent: calculatedYExtent
  };
};

var differenceCatch = function differenceCatch(olineType, data) {
  return olineType === "difference" && data.length !== 2 ? "line" : olineType;
};

function lineTransformation(lineType, options) {
  return function (data) {
    return builtInTransformations[differenceCatch(lineType.type, data)](_extends({}, lineType, options, {
      data: data
    }));
  };
}