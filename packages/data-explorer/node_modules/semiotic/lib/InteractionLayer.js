"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _class, _temp, _initialiseProps;

// components


var _react = require("react");

var _react2 = _interopRequireDefault(_react);

var _d3Brush = require("d3-brush");

var _d3Array = require("d3-array");

var _d3Selection = require("d3-selection");

var _d3Voronoi = require("d3-voronoi");

var _semioticMark = require("semiotic-mark");

var _Brush = require("./Brush");

var _Brush2 = _interopRequireDefault(_Brush);

var _propTypes = require("prop-types");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _SpanOrDiv = require("./SpanOrDiv");

var _SpanOrDiv2 = _interopRequireDefault(_SpanOrDiv);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//import type { CustomHoverType } from "./types/annotationTypes"

var InteractionLayer = (_temp = _class = function (_React$Component) {
  _inherits(InteractionLayer, _React$Component);

  function InteractionLayer(props) {
    _classCallCheck(this, InteractionLayer);

    // $FlowFixMe
    var _this = _possibleConstructorReturn(this, (InteractionLayer.__proto__ || Object.getPrototypeOf(InteractionLayer)).call(this, props));

    _initialiseProps.call(_this);

    _this.state = {
      overlayRegions: _this.calculateOverlay(props),
      interactionCanvas: _react2.default.createElement("canvas", {
        className: "frame-canvas-interaction",
        ref: function ref(canvasContext) {
          if (canvasContext) {
            canvasContext.onmousemove = function (e) {
              var interactionContext = canvasContext.getContext("2d");
              var hoverPoint = interactionContext.getImageData(e.offsetX, e.offsetY, 1, 1);

              var mostCommonRGB = "rgba(" + hoverPoint.data[0] + "," + hoverPoint.data[1] + "," + hoverPoint.data[2] + ",255)";

              // $FlowFixMe
              var overlay = _this.state.overlayRegions[_this.canvasMap.get(mostCommonRGB)];
              if (!overlay) {
                var hoverArea = interactionContext.getImageData(e.offsetX - 2, e.offsetY - 2, 5, 5);
                var _x = 0;

                while (!overlay && _x < 100) {
                  // $FlowFixMe
                  overlay = _this.state.overlayRegions[_this.canvasMap.get("rgba(" + hoverArea.data[_x] + "," + hoverArea.data[_x + 1] + "," + hoverArea.data[_x + 2] + ",255)")];
                  _x += 4;
                }
              }

              // $FlowFixMe
              if (overlay && overlay.props) {
                overlay.props.onMouseEnter();
              } else {
                _this.changeVoronoi();
              }
            };
          }
          _this.interactionContext = canvasContext;
        },
        style: {
          position: "absolute",
          left: "0px",
          top: "0px",
          imageRendering: "pixelated",
          pointerEvents: "all",
          opacity: 0
        },
        width: props.svgSize[0],
        height: props.svgSize[1]
      })
    };
    return _this;
  }

  _createClass(InteractionLayer, [{
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(nextProps) {
      if (this.props.overlay !== nextProps.overlay || nextProps.points !== this.props.points || this.props.xScale !== nextProps.xScale || this.props.yScale !== nextProps.yScale) {
        this.setState({ overlayRegions: this.calculateOverlay(nextProps) });
      }
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      this.canvasRendering();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps, prevState) {
      if (this.state.overlayRegions !== prevState.overlayRegions) {
        this.canvasRendering();
      }
    }
  }, {
    key: "render",
    value: function render() {
      var semioticBrush = null;
      var _props = this.props,
          interaction = _props.interaction,
          svgSize = _props.svgSize,
          margin = _props.margin,
          _props$useSpans = _props.useSpans,
          useSpans = _props$useSpans === undefined ? false : _props$useSpans,
          canvasRendering = _props.canvasRendering,
          disableCanvasInteraction = _props.disableCanvasInteraction;
      var overlayRegions = this.state.overlayRegions;
      var enabled = this.props.enabled;


      if (interaction && interaction.brush) {
        enabled = true;
        semioticBrush = this.createBrush(interaction);
      }
      if (interaction && interaction.columnsBrush) {
        enabled = true;
        semioticBrush = this.createColumnsBrush(interaction);
      }

      if (!overlayRegions && !semioticBrush) {
        return null;
      }

      var interactionCanvas = !disableCanvasInteraction && canvasRendering && this.state.overlayRegions && this.state.interactionCanvas;

      return _react2.default.createElement(
        _SpanOrDiv2.default,
        {
          span: useSpans,
          className: "interaction-layer",
          style: {
            position: "absolute",
            background: "none",
            pointerEvents: "none"
          }
        },
        interactionCanvas || _react2.default.createElement(
          "svg",
          {
            height: svgSize[1],
            width: svgSize[0],
            style: { background: "none", pointerEvents: "none" }
          },
          _react2.default.createElement(
            "g",
            {
              className: "interaction-overlay",
              transform: "translate(" + margin.left + "," + margin.top + ")",
              style: { pointerEvents: enabled ? "all" : "none" }
            },
            _react2.default.createElement(
              "g",
              { className: "interaction-regions" },
              overlayRegions
            ),
            semioticBrush
          )
        )
      );
    }
  }]);

  return InteractionLayer;
}(_react2.default.Component), _class.defaultProps = {
  svgSize: [500, 500]
}, _initialiseProps = function _initialiseProps() {
  var _this2 = this;

  this.interactionContext = null;
  this.canvasMap = new Map();

  this.changeVoronoi = function (d, customHoverTypes) {
    //Until semiotic 2
    var dataObject = d && d.data ? _extends({}, d.data, d) : d;
    if (_this2.props.customHoverBehavior) _this2.props.customHoverBehavior(dataObject);

    if (!d) _this2.props.voronoiHover(null);else if (customHoverTypes === true) {
      var vorD = _extends({}, dataObject);
      vorD.type = vorD.type === "column-hover" ? "column-hover" : "frame-hover";
      _this2.props.voronoiHover(vorD);
    } else if (customHoverTypes) {
      var arrayWrappedHoverTypes = Array.isArray(customHoverTypes) ? customHoverTypes : [customHoverTypes];
      var mappedHoverTypes = arrayWrappedHoverTypes.map(function (c) {
        var finalC = typeof c === "function" ? c(dataObject) : c;
        if (!finalC) return undefined;
        return _extends({}, dataObject, finalC);
      }).filter(function (d) {
        return d;
      });

      _this2.props.voronoiHover(mappedHoverTypes);
    }
  };

  this.clickVoronoi = function (d) {
    //Until semiotic 2
    var dataObject = d.data ? _extends({}, d.data, d) : d;

    if (_this2.props.customClickBehavior) _this2.props.customClickBehavior(dataObject);
  };

  this.doubleclickVoronoi = function (d) {
    //Until semiotic 2
    var dataObject = d.data ? _extends({}, d.data, d) : d;

    if (_this2.props.customDoubleClickBehavior) _this2.props.customDoubleClickBehavior(dataObject);
  };

  this.brushStart = function (e, column) {
    if (_this2.props.interaction && _this2.props.interaction.start) _this2.props.interaction.start(e, column);
  };

  this.brush = function (e, column) {
    if (_this2.props.interaction && _this2.props.interaction.during) _this2.props.interaction.during(e, column);
  };

  this.brushEnd = function (e, column) {
    if (_this2.props.interaction && _this2.props.interaction.end) _this2.props.interaction.end(e, column);
  };

  this.createBrush = function (interaction) {
    var semioticBrush = void 0,
        mappingFn = void 0,
        selectedExtent = void 0,
        endMappingFn = void 0;

    var _props2 = _this2.props,
        xScale = _props2.xScale,
        yScale = _props2.yScale,
        size = _props2.size;
    var projection = interaction.projection,
        projectedColumns = interaction.projectedColumns;


    var actualBrush = interaction.brush === "oBrush" ? projection === "horizontal" ? "yBrush" : "xBrush" : interaction.brush;

    var _interaction$extent = interaction.extent,
        extent = _interaction$extent === undefined ? actualBrush === "xyBrush" ? [[xScale.invert(0), yScale.invert(0)], [xScale.invert(size[0]), yScale.invert(size[1])]] : actualBrush === "xBrush" ? [xScale.invert(0), xScale.invert(size[0])] : [yScale.invert(0), yScale.invert(size[1])] : _interaction$extent;


    if (extent.indexOf && extent.indexOf(undefined) !== -1) {
      return _react2.default.createElement("g", null);
    }

    if (actualBrush === "xBrush") {
      mappingFn = function mappingFn(d) {
        return !d ? null : [xScale.invert(d[0]), xScale.invert(d[1])];
      };
      semioticBrush = (0, _d3Brush.brushX)();
      selectedExtent = extent.map(function (d) {
        return xScale(d);
      });
      endMappingFn = mappingFn;
    } else if (actualBrush === "yBrush") {
      mappingFn = function mappingFn(d) {
        return !d ? null : [yScale.invert(d[0]), yScale.invert(d[1])];
      };
      semioticBrush = (0, _d3Brush.brushY)();
      selectedExtent = extent.map(function (d) {
        return yScale(d);
      });
      endMappingFn = mappingFn;
    } else {
      if (extent.indexOf(undefined) !== -1 || extent[0].indexOf(undefined) !== -1 || extent[1].indexOf(undefined) !== -1) {
        return _react2.default.createElement("g", null);
      }

      semioticBrush = (0, _d3Brush.brush)();
      mappingFn = function mappingFn(d) {
        return !d ? null : [[xScale.invert(d[0][0]), yScale.invert(d[0][1])], [xScale.invert(d[1][0]), yScale.invert(d[1][1])]];
      };
      selectedExtent = extent.map(function (d) {
        return [xScale(d[0]), yScale(d[1])];
      });
      endMappingFn = mappingFn;
    }

    if (interaction.brush === "oBrush") {
      var oMappingFn = function oMappingFn(d) {
        if (d) {
          // $FlowFixMe
          var columnValues = Object.values(projectedColumns);

          var foundColumns = columnValues.filter(function (c) {
            // $FlowFixMe
            return d[1] >= c.x && d[0] <= c.x + c.width;
          });
          return foundColumns;
        }
        return null;
      };

      var oEndMappingFn = function oEndMappingFn(d) {
        if (d && _d3Selection.event.sourceEvent && _d3Selection.event.sourceEvent.path && _d3Selection.event.sourceEvent.path[1] && _d3Selection.event.sourceEvent.path[1].classList.contains("xybrush") && _d3Selection.event.target.move) {
          var foundColumns = Object.values(projectedColumns).filter(
          // $FlowFixMe
          function (c) {
            return d[1] >= c.x && d[0] <= c.x + c.width;
          });

          // $FlowFixMe
          var firstColumn = foundColumns[0] || {
            x: 0
            // $FlowFixMe
          };var lastColumn = foundColumns[foundColumns.length - 1] || {
            x: 0,
            width: 0
          };

          var columnPosition = [firstColumn.x + Math.min(5, firstColumn.width / 10), lastColumn.x + lastColumn.width - Math.min(5, lastColumn.width / 10)];

          (0, _d3Selection.select)(_d3Selection.event.sourceEvent.path[1]).transition(750).call(_d3Selection.event.target.move, columnPosition);

          return foundColumns;
        }
        return null;
      };

      selectedExtent = interaction.extent ? [projectedColumns[interaction.extent[0]].x, projectedColumns[interaction.extent[1]].x + projectedColumns[interaction.extent[1]].width] : null;

      mappingFn = oMappingFn;
      endMappingFn = oEndMappingFn;
    }

    semioticBrush.extent([[0, 0], [_this2.props.size[0], _this2.props.size[1]]]).on("start", function () {
      _this2.brushStart(mappingFn(_d3Selection.event.selection));
    }).on("brush", function () {
      _this2.brush(mappingFn(_d3Selection.event.selection));
    }).on("end", function () {
      _this2.brushEnd(endMappingFn(_d3Selection.event.selection));
    });

    return _react2.default.createElement(
      "g",
      { className: "brush" },
      _react2.default.createElement(_Brush2.default, {
        type: interaction.brush,
        selectedExtent: selectedExtent,
        extent: extent,
        svgBrush: semioticBrush,
        size: size
      })
    );
  };

  this.calculateOverlay = function (props) {
    var voronoiPaths = [];
    var xScale = props.xScale,
        yScale = props.yScale,
        points = props.points,
        projectedX = props.projectedX,
        projectedY = props.projectedY,
        projectedYMiddle = props.projectedYMiddle,
        size = props.size,
        overlay = props.overlay,
        _props$interactionOve = props.interactionOverflow,
        interactionOverflow = _props$interactionOve === undefined ? { top: 0, bottom: 0, left: 0, right: 0 } : _props$interactionOve,
        customClickBehavior = props.customClickBehavior,
        customDoubleClickBehavior = props.customDoubleClickBehavior;


    var pointerStyle = customClickBehavior || customDoubleClickBehavior ? { cursor: "pointer" } : {};

    if (points && props.hoverAnnotation && !overlay) {
      var voronoiDataset = [];
      var voronoiUniqueHash = {};

      points.forEach(function (d) {
        var xValue = parseInt(xScale(d[projectedX]), 10);
        var yValue = parseInt(yScale(d[projectedYMiddle] || d[projectedY]), 10);
        if (xValue >= 0 && xValue <= size[0] && yValue >= 0 && yValue <= size[1] && xValue !== undefined && yValue !== undefined && isNaN(xValue) === false && isNaN(yValue) === false) {
          var pointKey = xValue + "," + yValue;
          if (!voronoiUniqueHash[pointKey]) {
            var voronoiPoint = _extends({}, d, {
              coincidentPoints: [d],
              voronoiX: xValue,
              voronoiY: yValue
            });
            voronoiDataset.push(voronoiPoint);
            voronoiUniqueHash[pointKey] = voronoiPoint;
          } else voronoiUniqueHash[pointKey].coincidentPoints.push(d);
        }
      });

      var voronoiXExtent = (0, _d3Array.extent)(voronoiDataset.map(function (d) {
        return d.voronoiX;
      }));
      var voronoiYExtent = (0, _d3Array.extent)(voronoiDataset.map(function (d) {
        return d.voronoiY;
      }));

      var voronoiExtent = [[Math.min(voronoiXExtent[0], -interactionOverflow.left), Math.min(voronoiYExtent[0], -interactionOverflow.top)], [Math.max(voronoiXExtent[1], size[0] + interactionOverflow.right), Math.max(voronoiYExtent[1], size[1] + interactionOverflow.bottom)]];

      var voronoiDiagram = (0, _d3Voronoi.voronoi)().extent(voronoiExtent).x(function (d) {
        return d.voronoiX;
      }).y(function (d) {
        return d.voronoiY;
      });

      var voronoiData = voronoiDiagram.polygons(voronoiDataset);

      voronoiPaths = voronoiData.map(function (d, i) {
        return _react2.default.createElement("path", {
          onClick: function onClick() {
            _this2.clickVoronoi(voronoiDataset[i]);
          },
          onDoubleClick: function onDoubleClick() {
            _this2.doubleclickVoronoi(voronoiDataset[i]);
          },
          onMouseEnter: function onMouseEnter() {
            _this2.changeVoronoi(voronoiDataset[i], props.hoverAnnotation);
          },
          onMouseLeave: function onMouseLeave() {
            _this2.changeVoronoi();
          },
          key: "interactionVoronoi" + i,
          d: "M" + d.join("L") + "Z",
          style: _extends({ fillOpacity: 0 }, pointerStyle)
        });
      }, _this2);
      return voronoiPaths;
    } else if (overlay) {
      var renderedOverlay = overlay.map(function (overlayRegion, i) {
        var overlayData = overlayRegion.overlayData,
            rest = _objectWithoutProperties(overlayRegion, ["overlayData"]);

        if (_react2.default.isValidElement(overlayRegion.renderElement)) {
          return _react2.default.cloneElement(overlayRegion.renderElement, {
            key: "overlay-" + i,
            onMouseEnter: function onMouseEnter() {
              _this2.changeVoronoi(overlayData, props.hoverAnnotation);
            },
            onMouseLeave: function onMouseLeave() {
              _this2.changeVoronoi();
            },
            onClick: function onClick() {
              _this2.clickVoronoi(overlayData);
            },
            onDoubleClick: function onDoubleClick() {
              _this2.doubleclickVoronoi(overlayData);
            },
            style: _extends({ opacity: 0 }, pointerStyle)
          });
        } else {
          return _react2.default.createElement(_semioticMark.Mark, _extends({
            forceUpdate: true
          }, rest, {
            key: "overlay-" + i,
            onMouseEnter: function onMouseEnter() {
              _this2.changeVoronoi(overlayData, props.hoverAnnotation);
            },
            onMouseLeave: function onMouseLeave() {
              _this2.changeVoronoi();
            },
            onClick: function onClick() {
              _this2.clickVoronoi(overlayData);
            },
            onDoubleClick: function onDoubleClick() {
              _this2.doubleclickVoronoi(overlayData);
            },
            style: _extends({ opacity: 0 }, pointerStyle)
          }));
        }
      });

      return renderedOverlay;
    }
  };

  this.canvasRendering = function () {
    if (_this2.interactionContext === null || !_this2.state.overlayRegions) return;

    var _props3 = _this2.props,
        svgSize = _props3.svgSize,
        margin = _props3.margin;
    var overlayRegions = _this2.state.overlayRegions;


    _this2.canvasMap.clear();

    // $FlowFixMe
    var interactionContext = _this2.interactionContext.getContext("2d");

    interactionContext.imageSmoothingEnabled = false;
    interactionContext.setTransform(1, 0, 0, 1, margin.left, margin.top);
    interactionContext.clearRect(-margin.left, -margin.top, svgSize[0], svgSize[1]);

    interactionContext.lineWidth = 1;

    overlayRegions.forEach(function (overlay, oi) {
      var interactionRGBA = "rgba(" + parseInt(Math.random() * 255) + "," + parseInt(Math.random() * 255) + "," + parseInt(Math.random() * 255) + ",255)";

      _this2.canvasMap.set(interactionRGBA, oi);

      interactionContext.fillStyle = interactionRGBA;
      interactionContext.strokeStyle = interactionRGBA;

      // $FlowFixMe
      var p = new Path2D(overlay.props.d);
      interactionContext.stroke(p);
      interactionContext.fill(p);
    });
  };

  this.createColumnsBrush = function (interaction) {
    var _props4 = _this2.props,
        projection = _props4.projection,
        rScale = _props4.rScale,
        size = _props4.size,
        oColumns = _props4.oColumns;


    if (!projection || !rScale || !oColumns) return;

    var semioticBrush = void 0,
        mappingFn = void 0;

    var max = rScale.domain()[1];

    var type = "yBrush";

    if (projection && projection === "horizontal") {
      type = "xBrush";
      mappingFn = function mappingFn(d) {
        return !d ? null : [rScale.invert(d[0]), rScale.invert(d[1])];
      };
    } else mappingFn = function mappingFn(d) {
      return !d ? null : [Math.abs(rScale.invert(d[1]) - max), Math.abs(rScale.invert(d[0]) - max)];
    };

    var rRange = rScale.range();

    var columnHash = oColumns;
    var brushPosition = void 0,
        selectedExtent = void 0;
    var brushes = Object.keys(columnHash).map(function (c) {
      if (projection && projection === "horizontal") {
        selectedExtent = interaction.extent[c] ? interaction.extent[c].map(function (d) {
          return rScale(d);
        }) : rRange;
        brushPosition = [0, columnHash[c].x];
        semioticBrush = (0, _d3Brush.brushX)();
        semioticBrush.extent([[rRange[0], 0], [rRange[1], columnHash[c].width]]).on("start", function () {
          _this2.brushStart(mappingFn(_d3Selection.event.selection), c);
        }).on("brush", function () {
          _this2.brush(mappingFn(_d3Selection.event.selection), c);
        }).on("end", function () {
          _this2.brushEnd(mappingFn(_d3Selection.event.selection), c);
        });
      } else {
        selectedExtent = interaction.extent[c] ? interaction.extent[c].map(function (d) {
          return rRange[1] - rScale(d);
        }).reverse() : rRange;
        brushPosition = [columnHash[c].x, 0];
        semioticBrush = (0, _d3Brush.brushY)();
        semioticBrush.extent([[0, rRange[0]], [columnHash[c].width, rRange[1]]]).on("start", function () {
          _this2.brushStart(mappingFn(_d3Selection.event.selection), c);
        }).on("brush", function () {
          _this2.brush(mappingFn(_d3Selection.event.selection), c);
        }).on("end", function () {
          _this2.brushEnd(mappingFn(_d3Selection.event.selection), c);
        });
      }

      return _react2.default.createElement(
        "g",
        { key: "column-brush-" + c, className: "brush" },
        _react2.default.createElement(_Brush2.default, {
          type: type,
          position: brushPosition,
          key: "orbrush" + c,
          selectedExtent: selectedExtent,
          svgBrush: semioticBrush,
          size: size
        })
      );
    });
    return brushes;
  };
}, _temp);


InteractionLayer.propTypes = {
  name: _propTypes2.default.string,
  interaction: _propTypes2.default.object,
  overlay: _propTypes2.default.oneOfType([_propTypes2.default.array, _propTypes2.default.object, _propTypes2.default.bool]),
  oColumns: _propTypes2.default.object,
  xScale: _propTypes2.default.func,
  yScale: _propTypes2.default.func,
  rScale: _propTypes2.default.func,
  svgSize: _propTypes2.default.array
};

exports.default = InteractionLayer;
module.exports = exports['default'];