"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _class, _temp;

var _react = require("react");

var _react2 = _interopRequireDefault(_react);

var _d3Force = require("d3-force");

var _d3BboxCollide = require("d3-bboxCollide");

var _d3Scale = require("d3-scale");

var _d3Array = require("d3-array");

var _AnnotationLabel = require("react-annotation/lib/Types/AnnotationLabel");

var _AnnotationLabel2 = _interopRequireDefault(_AnnotationLabel);

var _Frame = require("./Frame");

var _Frame2 = _interopRequireDefault(_Frame);

var _DownloadButton = require("./DownloadButton");

var _DownloadButton2 = _interopRequireDefault(_DownloadButton);

var _frameFunctions = require("./svg/frameFunctions");

var _pieceDrawing = require("./svg/pieceDrawing");

var _networkDrawing = require("./svg/networkDrawing");

var _dataFunctions = require("./data/dataFunctions");

var _downloadDataMapping = require("./downloadDataMapping");

var _d3SankeyCircular = require("d3-sankey-circular");

var _d3Chord = require("d3-chord");

var _d3Shape = require("d3-shape");

var _d3Hierarchy = require("d3-hierarchy");

var _frame_props = require("./constants/frame_props");

var _networkframeRules = require("./annotationRules/networkframeRules");

var _functions = require("./untyped_utilities/functions");

var _svgPathBoundingBox = require("svg-path-bounding-box");

var _svgPathBoundingBox2 = _interopRequireDefault(_svgPathBoundingBox);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var emptyArray = [];

var baseNodeProps = {
  degree: 0,
  inDegree: 0,
  outDegree: 0,
  x: 0,
  y: 0,
  x1: 0,
  x0: 0,
  y1: 0,
  y0: 0,
  height: 0,
  width: 0,
  radius: 0,
  r: 0,
  direction: undefined,
  textHeight: 0,
  textWidth: 0,
  fontSize: 0,
  scale: 1,
  nodeSize: 0,
  component: -99,
  shapeNode: false
};

var baseNetworkSettings = {
  iterations: 500,
  hierarchicalNetwork: false
};

var baseGraphSettings = {
  nodeHash: new Map(),
  edgeHash: new Map(),
  nodes: [],
  edges: [],
  hierarchicalNetwork: false
};

var basicMiddle = function basicMiddle(d) {
  return {
    edge: d,
    x: (d.source.x + d.target.x) / 2,
    y: (d.source.y + d.target.y) / 2
  };
};

var edgePointHash = {
  sankey: function sankey(d) {
    return {
      edge: d,
      x: (d.source.x1 + d.target.x0) / 2,
      y: d.circularPathData ? d.circularPathData.verticalFullExtent : ((d.y0 + d.y1) / 2 + (d.y0 + d.y1) / 2) / 2
    };
  },
  force: basicMiddle,
  tree: basicMiddle,
  cluster: basicMiddle
};

var hierarchicalTypeHash = {
  dendrogram: _d3Hierarchy.tree,
  tree: _d3Hierarchy.tree,
  circlepack: _d3Hierarchy.pack,
  cluster: _d3Hierarchy.cluster,
  treemap: _d3Hierarchy.treemap,
  partition: _d3Hierarchy.partition
};

var hierarchicalProjectable = {
  partition: true,
  cluster: true,
  tree: true,
  dendrogram: true
};

var radialProjectable = {
  partition: true,
  cluster: true,
  tree: true,
  dendrogram: true

  /*
  const customEdgeHashProject = {
    offset: glyphProject.offset,
    parallel: glyphProject.parallel
  }
  
  const customEdgeHashMutate = {
    particle: glyphMutate.particle
  }
  */

};function determineNodeIcon(baseCustomNodeIcon, networkSettings, size) {
  if (baseCustomNodeIcon) return baseCustomNodeIcon;

  var center = [size[0] / 2, size[1] / 2];

  switch (networkSettings.type) {
    case "sankey":
      return _networkDrawing.sankeyNodeGenerator;
    case "partition":
      return networkSettings.projection === "radial" ? (0, _networkDrawing.radialRectNodeGenerator)(size, center, networkSettings) : _networkDrawing.hierarchicalRectNodeGenerator;
    case "treemap":
      return networkSettings.projection === "radial" ? (0, _networkDrawing.radialRectNodeGenerator)(size, center, networkSettings) : _networkDrawing.hierarchicalRectNodeGenerator;
    case "circlepack":
      return _networkDrawing.circleNodeGenerator;
    case "wordcloud":
      return _networkDrawing.wordcloudNodeGenerator;
    case "chord":
      return (0, _networkDrawing.chordNodeGenerator)(size);
    case "dagre":
      return _networkDrawing.hierarchicalRectNodeGenerator;
  }

  return _networkDrawing.circleNodeGenerator;
}

function determineEdgeIcon(baseCustomEdgeIcon, networkSettings, size, graph) {
  if (baseCustomEdgeIcon) return baseCustomEdgeIcon;
  switch (networkSettings.type) {
    case "partition":
      return function () {
        return null;
      };
    case "treemap":
      return function () {
        return null;
      };
    case "circlepack":
      return function () {
        return null;
      };
    case "wordcloud":
      return function () {
        return null;
      };
    case "chord":
      return (0, _networkDrawing.chordEdgeGenerator)(size);
    case "dagre":
      if (graph) return (0, _networkDrawing.dagreEdgeGenerator)(graph.graph().rankdir);
  }
  return undefined;
}

function breadthFirstCompontents(baseNodes, hash) {
  var componentHash = {
    "0": { componentNodes: [], componentEdges: [] }
  };
  var components = [componentHash["0"]];

  var componentID = 0;

  traverseNodesBF(baseNodes, true);

  function traverseNodesBF(nodes, top) {
    nodes.forEach(function (node) {
      var hashNode = hash.get(node);
      if (!hashNode) {
        componentHash["0"].componentNodes.push(node);
      } else if (hashNode.component === null) {
        var _componentHash$compon;

        if (top === true) {
          componentID++;
          componentHash[componentID] = {
            componentNodes: [],
            componentEdges: []
          };
          components.push(componentHash[componentID]);
        }

        hashNode.component = componentID;
        componentHash[componentID].componentNodes.push(node);
        (_componentHash$compon = componentHash[componentID].componentEdges).push.apply(_componentHash$compon, _toConsumableArray(hashNode.edges));
        var traversibleNodes = [].concat(_toConsumableArray(hashNode.connectedNodes));
        traverseNodesBF(traversibleNodes);
      }
    });
  }

  return components.sort(function (a, b) {
    return b.componentNodes.length - a.componentNodes.length;
  });
}

var projectedCoordinateNames = { y: "y", x: "x" };

function recursiveIDAccessor(idAccessor, node, accessorString) {
  if (node.parent) {
    accessorString = accessorString + "-" + recursiveIDAccessor(idAccessor, node.parent, accessorString);
  }
  return accessorString + "-" + idAccessor(node.data);
}

var sankeyOrientHash = {
  left: _d3SankeyCircular.sankeyLeft,
  right: _d3SankeyCircular.sankeyRight,
  center: _d3SankeyCircular.sankeyCenter,
  justify: _d3SankeyCircular.sankeyJustify
};

var xScale = (0, _d3Scale.scaleIdentity)();
var yScale = (0, _d3Scale.scaleIdentity)();

var matrixify = function matrixify(_ref) {
  var edgeHash = _ref.edgeHash,
      nodes = _ref.nodes,
      edgeWidthAccessor = _ref.edgeWidthAccessor,
      nodeIDAccessor = _ref.nodeIDAccessor;

  var matrix = [];
  nodes.forEach(function (nodeSource) {
    var nodeSourceID = nodeIDAccessor(nodeSource);
    var sourceRow = [];
    matrix.push(sourceRow);
    nodes.forEach(function (nodeTarget) {
      var nodeTargetID = nodeIDAccessor(nodeTarget);
      var theEdge = edgeHash.get(nodeSourceID + "|" + nodeTargetID);
      if (theEdge) {
        sourceRow.push(edgeWidthAccessor(theEdge));
      } else {
        sourceRow.push(0);
      }
    });
  });
  return matrix;
};

var NetworkFrame = (_temp = _class = function (_React$Component) {
  _inherits(NetworkFrame, _React$Component);

  function NetworkFrame(props) {
    _classCallCheck(this, NetworkFrame);

    var _this = _possibleConstructorReturn(this, (NetworkFrame.__proto__ || Object.getPrototypeOf(NetworkFrame)).call(this, props));

    _this.defaultNetworkSVGRule = function (_ref2) {
      var baseD = _ref2.d,
          i = _ref2.i;
      var _this$state = _this.state,
          projectedNodes = _this$state.projectedNodes,
          projectedEdges = _this$state.projectedEdges,
          nodeIDAccessor = _this$state.nodeIDAccessor,
          nodeSizeAccessor = _this$state.nodeSizeAccessor,
          networkFrameRender = _this$state.networkFrameRender;
      var svgAnnotationRules = _this.props.svgAnnotationRules;


      var d = baseD.ids ? baseD : baseD.edge ? _extends({}, projectedEdges.find(function (p) {
        return nodeIDAccessor(p.source) === nodeIDAccessor(baseD.source) && nodeIDAccessor(p.target) === nodeIDAccessor(baseD.target);
      }) || {}, baseD) : _extends({}, projectedNodes.find(function (p) {
        return nodeIDAccessor(p) === baseD.id;
      }) || {}, baseD);

      if (svgAnnotationRules) {
        var customAnnotation = svgAnnotationRules({
          d: d,
          i: i,
          networkFrameProps: _this.props,
          networkFrameState: _this.state,
          nodes: projectedNodes,
          edges: projectedEdges
        });
        if (customAnnotation !== null) {
          return customAnnotation;
        }
      }
      if (d.type === "node") {
        return (0, _networkframeRules.svgNodeRule)({
          d: d,
          i: i,
          projectedNodes: projectedNodes,
          nodeIDAccessor: nodeIDAccessor,
          nodeSizeAccessor: nodeSizeAccessor
        });
      } else if (d.type === "basic-node-label") {
        return _react2.default.createElement(
          "g",
          { key: d.key, transform: "translate(" + d.x + "," + d.y + ")" },
          d.element
        );
      } else if (d.type === "react-annotation" || typeof d.type === "function") {
        return (0, _networkframeRules.svgReactAnnotationRule)({
          d: d,
          projectedNodes: projectedNodes,
          nodeIDAccessor: nodeIDAccessor
        });
      } else if (d.type === "enclose") {
        return (0, _networkframeRules.svgEncloseRule)({
          d: d,
          i: i,
          projectedNodes: projectedNodes,
          nodeIDAccessor: nodeIDAccessor,
          nodeSizeAccessor: nodeSizeAccessor
        });
      } else if (d.type === "enclose-rect") {
        return (0, _networkframeRules.svgRectEncloseRule)({
          d: d,
          i: i,
          projectedNodes: projectedNodes,
          nodeIDAccessor: nodeIDAccessor,
          nodeSizeAccessor: nodeSizeAccessor
        });
      } else if (d.type === "enclose-hull") {
        return (0, _networkframeRules.svgHullEncloseRule)({
          d: d,
          i: i,
          projectedNodes: projectedNodes,
          nodeIDAccessor: nodeIDAccessor,
          nodeSizeAccessor: nodeSizeAccessor
        });
      } else if (d.type === "highlight") {
        return (0, _networkframeRules.svgHighlightRule)({
          d: d,
          i: i,
          nodeSizeAccessor: nodeSizeAccessor,
          networkFrameRender: networkFrameRender
        });
      }
      return null;
    };

    _this.defaultNetworkHTMLRule = function (_ref3) {
      var d = _ref3.d,
          i = _ref3.i;
      var _this$props = _this.props,
          tooltipContent = _this$props.tooltipContent,
          size = _this$props.size,
          useSpans = _this$props.useSpans;
      var _this$state2 = _this.state,
          projectedNodes = _this$state2.projectedNodes,
          projectedEdges = _this$state2.projectedEdges,
          nodeIDAccessor = _this$state2.nodeIDAccessor;

      if (_this.props.htmlAnnotationRules) {
        var customAnnotation = _this.props.htmlAnnotationRules({
          d: d,
          i: i,
          networkFrameProps: _this.props,
          networkFrameState: _this.state,
          nodes: projectedNodes,
          edges: projectedEdges
        });
        if (customAnnotation !== null) {
          return customAnnotation;
        }
      }
      if (d.type === "frame-hover") {
        return (0, _networkframeRules.htmlFrameHoverRule)({
          d: d,
          i: i,
          tooltipContent: tooltipContent,
          size: size,
          useSpans: useSpans,
          nodes: projectedNodes,
          edges: projectedEdges,
          nodeIDAccessor: nodeIDAccessor
        });
      }
      return null;
    };

    _this.state = {
      dataVersion: undefined,
      nodeData: [],
      edgeData: [],
      adjustedPosition: [],
      adjustedSize: [],
      backgroundGraphics: null,
      foregroundGraphics: null,
      projectedNodes: [],
      projectedEdges: [],
      renderNumber: 0,
      nodeLabelAnnotations: [],
      graphSettings: {
        type: "empty-start",
        nodes: [],
        edges: [],
        nodeHash: new Map(),
        edgeHash: new Map(),
        hierarchicalNetwork: false
      },
      edgeWidthAccessor: (0, _dataFunctions.stringToFn)("weight"),
      legendSettings: {},
      margin: { top: 0, left: 0, right: 0, bottom: 0 },
      networkFrameRender: {},
      nodeIDAccessor: (0, _dataFunctions.stringToFn)("id"),
      nodeSizeAccessor: (0, _functions.genericFunction)(5),
      overlay: [],
      projectedXYPoints: [],
      sourceAccessor: (0, _dataFunctions.stringToFn)("source"),
      targetAccessor: (0, _dataFunctions.stringToFn)("target"),
      title: { title: undefined }
    };
    return _this;
  }

  _createClass(NetworkFrame, [{
    key: "componentWillMount",
    value: function componentWillMount() {
      Object.keys(this.props).forEach(function (d) {
        if (!_frame_props.networkframeproptypes[d]) {
          if (_frame_props.xyframeproptypes[d]) {
            console.error(d + " is an XYFrame prop are you sure you're using the right frame?");
          } else if (_frame_props.ordinalframeproptypes[d]) {
            console.error(d + " is an OrdinalFrame prop are you sure you're using the right frame?");
          } else {
            console.error(d + " is not a valid NetworkFrame prop");
          }
        }
      });
      this.calculateNetworkFrame(this.props);
    }
  }, {
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(nextProps) {
      var _this2 = this;

      if (this.state.dataVersion && this.state.dataVersion !== nextProps.dataVersion || !this.state.projectedNodes && !this.state.projectedEdges) {
        this.calculateNetworkFrame(nextProps);
      } else if (this.props.size[0] !== nextProps.size[0] || this.props.size[1] !== nextProps.size[1] || !this.state.dataVersion && _frame_props.networkFrameChangeProps.find(function (d) {
        return _this2.props[d] !== nextProps[d];
      })) {
        this.calculateNetworkFrame(nextProps);
      }
    }
  }, {
    key: "onNodeClick",
    value: function onNodeClick(d, i) {
      if (this.props.onNodeClick) {
        this.props.onNodeClick(d, i);
      }
    }
  }, {
    key: "onNodeEnter",
    value: function onNodeEnter(d, i) {
      if (this.props.onNodeEnter) {
        this.props.onNodeEnter(d, i);
      }
    }
  }, {
    key: "onNodeOut",
    value: function onNodeOut(d, i) {
      if (this.props.onNodeOut) {
        this.props.onNodeOut(d, i);
      }
    }
  }, {
    key: "calculateNetworkFrame",
    value: function calculateNetworkFrame(currentProps) {
      var _this3 = this;

      var graph = currentProps.graph,
          _currentProps$nodes = currentProps.nodes,
          nodes = _currentProps$nodes === undefined ? graph && graph.nodes || emptyArray : _currentProps$nodes,
          _currentProps$edges = currentProps.edges,
          edges = _currentProps$edges === undefined ? graph && graph.edges || graph || emptyArray : _currentProps$edges,
          networkType = currentProps.networkType,
          size = currentProps.size,
          nodeStyle = currentProps.nodeStyle,
          nodeClass = currentProps.nodeClass,
          canvasNodes = currentProps.canvasNodes,
          edgeStyle = currentProps.edgeStyle,
          edgeClass = currentProps.edgeClass,
          canvasEdges = currentProps.canvasEdges,
          nodeRenderMode = currentProps.nodeRenderMode,
          edgeRenderMode = currentProps.edgeRenderMode,
          nodeLabels = currentProps.nodeLabels,
          baseTitle = currentProps.title,
          baseMargin = currentProps.margin,
          hoverAnnotation = currentProps.hoverAnnotation,
          baseCustomNodeIcon = currentProps.customNodeIcon,
          baseCustomEdgeIcon = currentProps.customEdgeIcon,
          filterRenderedNodes = currentProps.filterRenderedNodes;
      var edgeType = currentProps.edgeType;


      var networkSettings = void 0;

      var nodeHierarchicalIDFill = {};
      var networkSettingsKeys = ["type"];

      if (typeof networkType === "string") {
        networkSettings = _extends({
          type: networkType
        }, baseNetworkSettings, {
          graphSettings: baseGraphSettings
        });
      } else {
        if (networkType) networkSettingsKeys = Object.keys(networkType);

        networkSettings = _extends({
          type: "force"
        }, baseNetworkSettings, networkType, {
          graphSettings: baseGraphSettings
        });
      }

      networkSettingsKeys.push("height", "width");

      var title = (typeof baseTitle === "undefined" ? "undefined" : _typeof(baseTitle)) === "object" && !_react2.default.isValidElement(baseTitle) && baseTitle !== null ? baseTitle : { title: baseTitle, orient: "top" };

      var margin = (0, _frameFunctions.calculateMargin)({
        margin: baseMargin,
        title: title
      });

      var _adjustedPositionSize = (0, _frameFunctions.adjustedPositionSize)({
        size: size,
        margin: margin
      }),
          adjustedPosition = _adjustedPositionSize.adjustedPosition,
          adjustedSize = _adjustedPositionSize.adjustedSize;

      var customNodeIcon = determineNodeIcon(baseCustomNodeIcon, networkSettings, adjustedSize);
      var customEdgeIcon = determineEdgeIcon(baseCustomEdgeIcon, networkSettings, adjustedSize, graph);

      networkSettings.graphSettings.nodes = nodes;
      networkSettings.graphSettings.edges = edges;

      var _networkSettings$grap = networkSettings.graphSettings,
          edgeHash = _networkSettings$grap.edgeHash,
          nodeHash = _networkSettings$grap.nodeHash;


      var createPointLayer = ["treemap", "partition", "sankey"].indexOf(networkSettings.type) !== -1;

      var nodeIDAccessor = (0, _dataFunctions.stringToFn)(currentProps.nodeIDAccessor, function (d) {
        return d.id;
      });
      var sourceAccessor = (0, _dataFunctions.stringToFn)(currentProps.sourceAccessor, function (d) {
        return d.source;
      });
      var targetAccessor = (0, _dataFunctions.stringToFn)(currentProps.targetAccessor, function (d) {
        return d.target;
      });
      // $FlowFixMe
      var nodeSizeAccessor = typeof currentProps.nodeSizeAccessor === "number" ? (0, _functions.genericFunction)(currentProps.nodeSizeAccessor) : (0, _dataFunctions.stringToFn)(currentProps.nodeSizeAccessor, function (d) {
        return d.r || 5;
      });
      var edgeWidthAccessor = (0, _dataFunctions.stringToFn)(currentProps.edgeWidthAccessor, function (d) {
        return d.weight || 1;
      });
      var nodeStyleFn = (0, _dataFunctions.stringToFn)(nodeStyle, function () {
        return {};
      }, true);
      var nodeClassFn = (0, _dataFunctions.stringToFn)(nodeClass, function () {
        return "";
      }, true);
      var nodeRenderModeFn = (0, _dataFunctions.stringToFn)(nodeRenderMode, undefined, true);
      var nodeCanvasRenderFn = canvasNodes && (0, _dataFunctions.stringToFn)(canvasNodes, undefined, true);

      var _state = this.state,
          projectedNodes = _state.projectedNodes,
          projectedEdges = _state.projectedEdges;


      var changedData = !this.state.projectedNodes || !this.state.projectedEdges || this.state.graphSettings.nodes !== nodes || this.state.graphSettings.edges !== edges || hierarchicalTypeHash[networkSettings.type];

      if (networkSettings.type === "dagre" && graph) {
        var dagreGraph = graph;
        var dagreNodeHash = {};
        projectedNodes = dagreGraph.nodes().map(function (n) {
          var baseNode = dagreGraph.node(n);
          dagreNodeHash[n] = _extends({}, baseNode, {
            x0: baseNode.x - baseNode.width / 2,
            x1: baseNode.x + baseNode.width / 2,
            y0: baseNode.y - baseNode.height / 2,
            y1: baseNode.y + baseNode.height / 2,
            id: n,
            shapeNode: true,
            sourceLinks: [],
            targetLinks: []
          });
          return dagreNodeHash[n];
        });
        projectedEdges = dagreGraph.edges().map(function (e) {
          var baseEdge = dagreGraph.edge(e);

          baseEdge.source = projectedNodes.find(function (p) {
            return p.id === e.v;
          });
          baseEdge.target = projectedNodes.find(function (p) {
            return p.id === e.w;
          });
          baseEdge.points.unshift({ x: baseEdge.source.x, y: baseEdge.source.y });
          baseEdge.points.push({ x: baseEdge.target.x, y: baseEdge.target.y });
          dagreNodeHash[e.v].targetLinks.push(baseEdge);
          dagreNodeHash[e.w].sourceLinks.push(baseEdge);
          return baseEdge;
        });
      } else if (changedData) {
        edgeHash = new Map();
        nodeHash = new Map();
        networkSettings.graphSettings.edgeHash = edgeHash;
        networkSettings.graphSettings.nodeHash = nodeHash;
        projectedNodes = [];
        projectedEdges = [];
        nodes.forEach(function (node) {
          var id = nodeIDAccessor(node);
          nodeHash.set(id, node);
          nodeHash.set(node, node);
          projectedNodes.push(node);
          node.id = id;
          node.inDegree = 0;
          node.outDegree = 0;
          node.degree = 0;
        });

        var operationalEdges = edges;

        if (!Array.isArray(edges)) {
          networkSettings.hierarchicalNetwork = true;
          var rootNode = (0, _d3Hierarchy.hierarchy)(edges, networkSettings.hierarchyChildren);

          rootNode.sum(networkSettings.hierarchySum || function (d) {
            return d.value;
          });

          if (hierarchicalTypeHash[networkSettings.type]) {
            var layout = networkSettings.layout || hierarchicalTypeHash[networkSettings.type];
            var hierarchicalLayout = layout();
            var networkSettingKeys = Object.keys(networkSettings);

            networkSettingKeys.forEach(function (key) {
              if (hierarchicalLayout[key]) {
                hierarchicalLayout[key](networkSettings[key]);
              }
            });
            var layoutSize = networkSettings.projection === "horizontal" && hierarchicalProjectable[networkSettings.type] ? [adjustedSize[1], adjustedSize[0]] : adjustedSize;
            if (!networkSettings.nodeSize) {
              hierarchicalLayout.size(layoutSize);
            }
            hierarchicalLayout(rootNode);
          }

          operationalEdges = rootNode.descendants().filter(function (d) {
            return d.parent !== null;
          }).map(function (d) {
            return {
              source: _extends(d.parent, d.parent.data),
              target: _extends(d, d.data),
              depth: d.depth,
              weight: 1,
              value: 1,
              _NWFEdgeKey: nodeIDAccessor(d.data) + "-" + recursiveIDAccessor(nodeIDAccessor, d.parent, "")
            };
          });
        }

        baseNodeProps.shapeNode = createPointLayer;

        operationalEdges.forEach(function (edge) {
          var source = sourceAccessor(edge);
          var target = targetAccessor(edge);
          var sourceTarget = [source, target];
          sourceTarget.forEach(function (nodeDirection) {
            if (!nodeHash.get(nodeDirection)) {
              var nodeObject = (typeof nodeDirection === "undefined" ? "undefined" : _typeof(nodeDirection)) === "object" ? _extends({}, baseNodeProps, nodeDirection) : _extends({
                id: nodeDirection
              }, baseNodeProps, {
                createdByFrame: true
              });
              var nodeIDValue = nodeObject.id || nodeIDAccessor(nodeObject);
              nodeHierarchicalIDFill[nodeIDValue] ? nodeHierarchicalIDFill[nodeIDValue] += 1 : nodeHierarchicalIDFill[nodeIDValue] = 1;
              if (!nodeObject.id) {
                var nodeSuffix = nodeHierarchicalIDFill[nodeIDValue] === 1 ? "" : "-" + nodeHierarchicalIDFill[nodeIDValue];
                nodeObject.id = "" + nodeIDValue + nodeSuffix;
              }

              nodeHash.set(nodeDirection, nodeObject);
              projectedNodes.push(nodeObject);
            }
          });

          var edgeWeight = edge.weight || 1;

          // $FlowFixMe
          nodeHash.get(target).inDegree += edgeWeight;
          // $FlowFixMe
          nodeHash.get(source).outDegree += edgeWeight;
          // $FlowFixMe
          nodeHash.get(target).degree += edgeWeight;
          // $FlowFixMe
          nodeHash.get(source).degree += edgeWeight;

          var edgeKey = (nodeIDAccessor(source) || source) + "|" + (nodeIDAccessor(target) || target);
          var newEdge = _extends({}, edge, {
            source: nodeHash.get(source),
            target: nodeHash.get(target)
          });
          edgeHash.set(edgeKey, newEdge);
          projectedEdges.push(newEdge);
        });
      } else {
        edgeHash = new Map();
        networkSettings.graphSettings.edgeHash = edgeHash;
        projectedEdges.forEach(function (edge) {
          var edgeKey = (nodeIDAccessor(edge.source) || edge.source) + "|" + (nodeIDAccessor(edge.target) || edge.target);
          edgeHash.set(edgeKey, edge);
        });
      }

      if ((networkSettings.type === "sankey" || networkSettings.type === "flowchart") && (0, _networkDrawing.topologicalSort)(projectedNodes, projectedEdges) === null) {
        networkSettings.customSankey = _d3SankeyCircular.sankeyCircular;
      }
      networkSettings.width = size[0];
      networkSettings.height = size[1];

      var networkSettingsChanged = false;

      networkSettingsKeys.forEach(function (key) {
        if (key !== "edgeType" && key !== "graphSettings" && networkSettings[key] !== _this3.state.graphSettings[key]) {
          networkSettingsChanged = true;
        }
      });

      //Support bubble chart with circle pack and with force
      if (networkSettings.type === "sankey") {
        edgeType = function (_edgeType) {
          function edgeType(_x) {
            return _edgeType.apply(this, arguments);
          }

          edgeType.toString = function () {
            return _edgeType.toString();
          };

          return edgeType;
        }(function (d) {
          return d.circular ? (0, _networkDrawing.circularAreaLink)(d) : edgeType === "angled" ? (0, _networkDrawing.ribbonLink)(d) : (0, _networkDrawing.areaLink)(d);
        });
      } else if (hierarchicalTypeHash[networkSettings.type]) {
        projectedNodes.forEach(function (node) {
          if (createPointLayer) {
            node.x = (node.x0 + node.x1) / 2;
            node.y = (node.y0 + node.y1) / 2;
          }
          if (hierarchicalProjectable[networkSettings.type] && networkSettings.projection === "horizontal") {
            var ox = node.x;
            node.x = node.y;
            node.y = ox;

            if (createPointLayer) {
              var ox0 = node.x0;
              var ox1 = node.x1;
              node.x0 = node.y0;
              node.x1 = node.y1;
              node.y0 = ox0;
              node.y1 = ox1;
            }
          } else if (radialProjectable[networkSettings.type] && networkSettings.projection === "radial") {
            var radialPoint = node.depth === 0 ? [adjustedSize[0] / 2, adjustedSize[1] / 2] : (0, _pieceDrawing.pointOnArcAtAngle)([adjustedSize[0] / 2, adjustedSize[1] / 2], node.x / adjustedSize[0], node.y / 2);
            node.x = radialPoint[0];
            node.y = radialPoint[1];
          } else {
            node.x = node.x;
            node.y = node.y;
            if (createPointLayer) {
              node.x0 = node.x0;
              node.x1 = node.x1;
              node.y0 = node.y0;
              node.y1 = node.y1;
            }
          }
        });
      }

      if (networkSettings.type !== "static" && (changedData || networkSettingsChanged)) {
        var components = [{
          componentNodes: projectedNodes,
          componentEdges: projectedEdges
        }];

        if (networkSettings.type === "chord") {
          var _radius = size[1] / 2;

          var _networkSettings = networkSettings,
              _networkSettings$grou = _networkSettings.groupWidth,
              _groupWidth = _networkSettings$grou === undefined ? 20 : _networkSettings$grou,
              _networkSettings$padA = _networkSettings.padAngle,
              _padAngle = _networkSettings$padA === undefined ? 0.01 : _networkSettings$padA,
              _sortGroups = _networkSettings.sortGroups;

          var arcGenerator = (0, _d3Shape.arc)().innerRadius(_radius - _groupWidth).outerRadius(_radius);

          var ribbonGenerator = (0, _d3Chord.ribbon)().radius(_radius - _groupWidth);

          var matrixifiedNetwork = matrixify({
            edgeHash: edgeHash,
            nodes: projectedNodes,
            edges: projectedEdges,
            edgeWidthAccessor: edgeWidthAccessor,
            nodeIDAccessor: nodeIDAccessor
          });

          var chordLayout = (0, _d3Chord.chord)().padAngle(_padAngle);

          if (_sortGroups) {
            chordLayout.sortGroups(_sortGroups);
          }

          var chords = chordLayout(matrixifiedNetwork);
          var groups = chords.groups;

          groups.forEach(function (group) {
            var groupCentroid = arcGenerator.centroid(group);
            var groupD = arcGenerator(group);
            var groupNode = projectedNodes[group.index];
            groupNode.d = groupD;
            groupNode.index = group.index;
            groupNode.x = groupCentroid[0] + size[0] / 2;
            groupNode.y = groupCentroid[1] + size[1] / 2;
          });

          chords.forEach(function (generatedChord) {
            var chordD = ribbonGenerator(generatedChord);

            //this is incorrect should use edgeHash
            var nodeSourceID = nodeIDAccessor(projectedNodes[generatedChord.source.index]);
            var nodeTargetID = nodeIDAccessor(projectedNodes[generatedChord.target.index]);
            var chordEdge = edgeHash.get(nodeSourceID + "|" + nodeTargetID);
            // $FlowFixMe
            chordEdge.d = chordD;
            var chordBounds = (0, _svgPathBoundingBox2.default)(chordD);
            // $FlowFixMe
            chordEdge.x = size[0] / 2 + (chordBounds.x1 + chordBounds.x2) / 2;
            // $FlowFixMe
            chordEdge.y = size[1] / 2 + (chordBounds.y1 + chordBounds.y2) / 2;
          });
        } else if (networkSettings.type === "sankey" || networkSettings.type === "flowchart") {
          var _networkSettings2 = networkSettings,
              _networkSettings2$ori = _networkSettings2.orient,
              _orient = _networkSettings2$ori === undefined ? "center" : _networkSettings2$ori,
              _networkSettings2$ite = _networkSettings2.iterations,
              _iterations = _networkSettings2$ite === undefined ? 100 : _networkSettings2$ite,
              _nodePadding = _networkSettings2.nodePadding,
              _networkSettings2$nod = _networkSettings2.nodePaddingRatio,
              _nodePaddingRatio = _networkSettings2$nod === undefined ? _nodePadding ? undefined : 0.5 : _networkSettings2$nod,
              _networkSettings2$nod2 = _networkSettings2.nodeWidth,
              _nodeWidth = _networkSettings2$nod2 === undefined ? networkSettings.type === "flowchart" ? 2 : 24 : _networkSettings2$nod2,
              _customSankey = _networkSettings2.customSankey,
              _networkSettings2$dir = _networkSettings2.direction,
              _direction = _networkSettings2$dir === undefined ? "right" : _networkSettings2$dir;

          var sankeyOrient = sankeyOrientHash[_orient];

          var actualSankey = _customSankey || _d3SankeyCircular.sankeyCircular;

          var frameExtent = [[0, 0], adjustedSize];

          if (networkSettings.direction === "up" || networkSettings.direction === "down") {
            frameExtent = [[0, 0], [adjustedSize[1], adjustedSize[0]]];
          }

          var frameSankey = actualSankey().extent(frameExtent).links(projectedEdges).nodes(projectedNodes).nodeAlign(sankeyOrient).nodeId(nodeIDAccessor).nodeWidth(_nodeWidth).iterations(_iterations);

          if (frameSankey.nodePaddingRatio && _nodePaddingRatio) {
            frameSankey.nodePaddingRatio(_nodePaddingRatio);
          } else if (_nodePadding) {
            frameSankey.nodePadding(_nodePadding);
          }

          frameSankey();

          projectedNodes.forEach(function (d) {
            d.height = d.y1 - d.y0;
            d.width = d.x1 - d.x0;
            d.x = d.x0 + d.width / 2;
            d.y = d.y0 + d.height / 2;
            d.radius = d.height / 2;
            d.direction = _direction;
          });

          projectedEdges.forEach(function (d) {
            d.sankeyWidth = d.width;
            d.direction = _direction;
            d.width = undefined;
          });
        } else if (networkSettings.type === "wordcloud") {
          var _networkSettings3 = networkSettings,
              _networkSettings3$ite = _networkSettings3.iterations,
              _iterations2 = _networkSettings3$ite === undefined ? 500 : _networkSettings3$ite,
              _networkSettings3$fon = _networkSettings3.fontSize,
              _fontSize = _networkSettings3$fon === undefined ? 18 : _networkSettings3$fon,
              _rotate = _networkSettings3.rotate,
              _networkSettings3$fon2 = _networkSettings3.fontWeight,
              _fontWeight = _networkSettings3$fon2 === undefined ? 300 : _networkSettings3$fon2,
              _networkSettings3$tex = _networkSettings3.textAccessor,
              _textAccessor = _networkSettings3$tex === undefined ? function (d) {
            return d.text;
          } : _networkSettings3$tex;

          var fontWeightMod = (_fontWeight / 300 - 1) / 5 + 1;
          var fontWidth = _fontSize / 1.5 * fontWeightMod;

          nodes.forEach(function (d, i) {
            var calcualatedNodeSize = nodeSizeAccessor(d);
            d._NWFText = _textAccessor(d);
            var textWidth = fontWidth * d._NWFText.length * calcualatedNodeSize * 1.4;
            var textHeight = _fontSize * calcualatedNodeSize;

            d.textHeight = textHeight + 4;
            d.textWidth = textWidth + 4;
            d.rotate = _rotate ? _rotate(d, i) : 0;
            d.fontSize = _fontSize * calcualatedNodeSize;
            d.fontWeight = _fontWeight;
            d.radius = d.r = textWidth / 2;
          });

          nodes.sort(function (a, b) {
            return b.textWidth - a.textWidth;
          });

          //bubblepack for initial position
          (0, _d3Hierarchy.packSiblings)(nodes);

          //        if (rotate) {
          var collide = (0, _d3BboxCollide.bboxCollide)(function (d) {
            if (d.rotate) {
              return [[-d.textHeight / 2, -d.textWidth / 2], [d.textHeight / 2, d.textWidth / 2]];
            }
            return [[-d.textWidth / 2, -d.textHeight / 2], [d.textWidth / 2, d.textHeight / 2]];
          }).iterations(1);

          var xCenter = size[0] / 2;
          var yCenter = size[1] / 2;

          var simulation = (0, _d3Force.forceSimulation)(nodes).velocityDecay(0.6).force("x", (0, _d3Force.forceX)(xCenter).strength(1.2)).force("y", (0, _d3Force.forceY)(yCenter).strength(1.2)).force("collide", collide);

          simulation.stop();

          for (var i = 0; i < _iterations2; ++i) {
            simulation.tick();
          } //      }

          var xMin = (0, _d3Array.min)(projectedNodes.map(function (p) {
            return p.x - (p.rotate ? p.textHeight / 2 : p.textWidth / 2);
          }));
          var xMax = (0, _d3Array.max)(projectedNodes.map(function (p) {
            return p.x + (p.rotate ? p.textHeight / 2 : p.textWidth / 2);
          }));
          var yMin = (0, _d3Array.min)(projectedNodes.map(function (p) {
            return p.y - (p.rotate ? p.textWidth / 2 : p.textHeight / 2);
          }));
          var yMax = (0, _d3Array.max)(projectedNodes.map(function (p) {
            return p.y + (p.rotate ? p.textWidth / 2 : p.textHeight / 2);
          }));
          var projectionScaleX = (0, _d3Scale.scaleLinear)().domain([xMin, xMax]).range([0, adjustedSize[0]]);
          var projectionScaleY = (0, _d3Scale.scaleLinear)().domain([yMin, yMax]).range([0, adjustedSize[1]]);
          var xMod = adjustedSize[0] / xMax;
          var yMod = adjustedSize[1] / yMax;

          var sizeMod = Math.min(xMod, yMod) * 1.2;
          projectedNodes.forEach(function (node) {
            node.x = projectionScaleX(node.x);
            node.y = projectionScaleY(node.y);
            node.fontSize = node.fontSize * sizeMod;
            node.scale = 1;
            node.radius = node.r = Math.max(node.textHeight / 4 * yMod, node.textWidth / 4 * xMod);
            //      node.textHeight = projectionScaleY(node.textHeight)
            //      node.textWidth = projectionScaleY(node.textWidth)
          });
        } else if (networkSettings.type === "force") {
          var _networkSettings4 = networkSettings,
              _networkSettings4$ite = _networkSettings4.iterations,
              _iterations3 = _networkSettings4$ite === undefined ? 500 : _networkSettings4$ite,
              _networkSettings4$edg = _networkSettings4.edgeStrength,
              _edgeStrength = _networkSettings4$edg === undefined ? 0.1 : _networkSettings4$edg,
              _networkSettings4$dis = _networkSettings4.distanceMax,
              _distanceMax = _networkSettings4$dis === undefined ? Infinity : _networkSettings4$dis,
              _edgeDistance = _networkSettings4.edgeDistance;

          var linkForce = (0, _d3Force.forceLink)().strength(function (d) {
            return Math.min(2.5, d.weight ? d.weight * _edgeStrength : _edgeStrength);
          });

          if (_edgeDistance) {
            linkForce.distance(_edgeDistance);
          }

          var _simulation = networkSettings.simulation || (0, _d3Force.forceSimulation)().force("charge", (0, _d3Force.forceManyBody)().distanceMax(_distanceMax).strength(networkSettings.forceManyBody || function (d) {
            return -25 * nodeSizeAccessor(d);
          }));

          //        simulation.force("link", linkForce).nodes(projectedNodes)

          _simulation.nodes(projectedNodes);

          if (!_simulation.force("x")) {
            _simulation.force("x", (0, _d3Force.forceX)(size[0] / 2));
          }
          if (!_simulation.force("y")) {
            _simulation.force("y", (0, _d3Force.forceY)(size[1] / 2));
          }

          if (projectedEdges.length !== 0 && !_simulation.force("link")) {
            _simulation.force("link", linkForce);
            _simulation.force("link").links(projectedEdges);
          }

          //reset alpha if it's too cold
          if (_simulation.alpha() < 0.1) {
            _simulation.alpha(1);
          }

          _simulation.stop();

          for (var _i = 0; _i < _iterations3; ++_i) {
            _simulation.tick();
          }
        } else if (networkSettings.type === "motifs") {
          var componentHash = new Map();
          projectedEdges.forEach(function (edge) {
            ;[edge.source, edge.target].forEach(function (node) {
              if (!componentHash.get(node)) {
                componentHash.set(node, {
                  node: node,
                  component: -99,
                  connectedNodes: [],
                  edges: []
                });
              }
            });
            // $FlowFixMe
            componentHash.get(edge.source).connectedNodes.push(edge.target);
            // $FlowFixMe
            componentHash.get(edge.target).connectedNodes.push(edge.source);
            // $FlowFixMe
            componentHash.get(edge.source).edges.push(edge);
          });

          components = breadthFirstCompontents(projectedNodes, componentHash);

          var largestComponent = Math.max(projectedNodes.length / 3, components[0].componentNodes.length);

          var _layoutSize = size[0] > size[1] ? size[1] : size[0];
          var layoutDirection = size[0] > size[1] ? "horizontal" : "vertical";

          var _networkSettings5 = networkSettings,
              _networkSettings5$ite = _networkSettings5.iterations,
              _iterations4 = _networkSettings5$ite === undefined ? 500 : _networkSettings5$ite,
              _networkSettings5$edg = _networkSettings5.edgeStrength,
              _edgeStrength2 = _networkSettings5$edg === undefined ? 0.1 : _networkSettings5$edg,
              _edgeDistance2 = _networkSettings5.edgeDistance;

          var currentX = 0;
          var currentY = 0;

          components.forEach(function (_ref4) {
            var componentNodes = _ref4.componentNodes,
                componentEdges = _ref4.componentEdges;

            var linkForce = (0, _d3Force.forceLink)().strength(function (d) {
              return Math.min(2.5, d.weight ? d.weight * _edgeStrength2 : _edgeStrength2);
            });

            if (_edgeDistance2) {
              linkForce.distance(_edgeDistance2);
            }

            var componentLayoutSize = Math.max(componentNodes.length / largestComponent, 0.2) * _layoutSize;

            var xBound = componentLayoutSize + currentX;
            var yBound = componentLayoutSize + currentY;

            if (layoutDirection === "horizontal") {
              if (yBound > size[1]) {
                currentX = componentLayoutSize + currentX;
                currentY = componentLayoutSize;
              } else {
                currentY = componentLayoutSize + currentY;
              }
            } else {
              if (xBound > size[0]) {
                currentY = componentLayoutSize + currentY;
                currentX = componentLayoutSize;
              } else {
                currentX = componentLayoutSize + currentX;
              }
            }

            var xCenter = currentX - componentLayoutSize / 2;
            var yCenter = currentY - componentLayoutSize / 2;

            var simulation = (0, _d3Force.forceSimulation)().force("charge", (0, _d3Force.forceManyBody)().strength(networkSettings.forceManyBody || function (d) {
              return -25 * nodeSizeAccessor(d);
            })).force("link", linkForce);

            simulation.force("x", (0, _d3Force.forceX)(xCenter)).force("y", (0, _d3Force.forceY)(yCenter)).nodes(componentNodes);

            simulation.force("link").links(componentEdges);

            simulation.stop();

            for (var _i2 = 0; _i2 < _iterations4; ++_i2) {
              simulation.tick();
            }var maxX = (0, _d3Array.max)(componentNodes.map(function (d) {
              return d.x;
            }));
            var maxY = (0, _d3Array.max)(componentNodes.map(function (d) {
              return d.y;
            }));
            var minX = (0, _d3Array.min)(componentNodes.map(function (d) {
              return d.x;
            }));
            var minY = (0, _d3Array.min)(componentNodes.map(function (d) {
              return d.y;
            }));

            var resetX = (0, _d3Scale.scaleLinear)().domain([minX, maxX]).range([currentX - componentLayoutSize, currentX - 20]);
            var resetY = (0, _d3Scale.scaleLinear)().domain([minY, maxY]).range([currentY - componentLayoutSize, currentY - 20]);

            componentNodes.forEach(function (node) {
              node.x = resetX(node.x);
              node.y = resetY(node.y);
            });
          });
        } else if (typeof networkSettings.type === "function") {
          networkSettings.type({
            nodes: projectedNodes,
            edges: projectedEdges
          });
        } else {
          projectedNodes.forEach(function (node) {
            node.x = node.x === undefined ? (node.x0 + node.x1) / 2 : node.x;
            node.y = node.y === undefined ? node.y0 : node.y;
          });
        }

        this.state.graphSettings.nodes = currentProps.nodes;
        this.state.graphSettings.edges = currentProps.edges;
      }

      //filter out user-defined nodes
      projectedNodes = projectedNodes.filter(filterRenderedNodes);
      projectedEdges = projectedEdges.filter(function (d) {
        return projectedNodes.indexOf(d.target) !== -1 && projectedNodes.indexOf(d.source) !== -1;
      });

      if (networkSettings.direction === "flip") {
        projectedNodes.forEach(function (node) {
          // const ox = node.x
          // const oy = node.y
          node.x = adjustedSize[0] - node.x;
          node.y = adjustedSize[1] - node.y;
        });
      } else if (networkSettings.direction === "up") {
        projectedNodes.forEach(function (node) {
          var ox = node.x;
          node.x = node.y;
          node.y = adjustedSize[1] - ox;
        });
      } else if (networkSettings.direction === "down") {
        projectedNodes.forEach(function (node) {
          var ox = node.x;
          var ox0 = node.x0;
          var ox1 = node.x1;
          node.x = node.y;
          node.x0 = node.y0;
          node.x1 = node.y1;
          node.y = ox;
          node.y0 = ox0;
          node.y1 = ox1;
        });
      } else if (networkSettings.direction === "left") {
        projectedNodes.forEach(function (node) {
          node.x = adjustedSize[0] - node.x;
        });
      }
      if (networkSettings.zoom !== false && networkSettings.type !== "wordcloud" && networkSettings.type !== "chord" && networkSettings.type !== "sankey" && networkSettings.type !== "partition" && networkSettings.type !== "treemap" && networkSettings.type !== "circlepack" && networkSettings.type !== "dagre") {
        var _xMin = (0, _d3Array.min)(projectedNodes.map(function (p) {
          return p.x - nodeSizeAccessor(p);
        }));
        var _xMax = (0, _d3Array.max)(projectedNodes.map(function (p) {
          return p.x + nodeSizeAccessor(p);
        }));
        var _yMin = (0, _d3Array.min)(projectedNodes.map(function (p) {
          return p.y - nodeSizeAccessor(p);
        }));
        var _yMax = (0, _d3Array.max)(projectedNodes.map(function (p) {
          return p.y + nodeSizeAccessor(p);
        }));

        var _projectionScaleX = (0, _d3Scale.scaleLinear)().domain([_xMin, _xMax]).range([margin.left, adjustedSize[0] - margin.right]);
        var _projectionScaleY = (0, _d3Scale.scaleLinear)().domain([_yMin, _yMax]).range([margin.top, adjustedSize[1] - margin.bottom]);
        projectedNodes.forEach(function (node) {
          node.x = _projectionScaleX(node.x);
          node.y = _projectionScaleY(node.y);
        });
      } else if (networkSettings.zoom !== false && networkSettings.projection !== "radial" && (networkSettings.type === "partition" || networkSettings.type === "treemap" || networkSettings.type === "dagre")) {
        var _xMin2 = (0, _d3Array.min)(projectedNodes.map(function (p) {
          return p.x0;
        }));
        var _xMax2 = (0, _d3Array.max)(projectedNodes.map(function (p) {
          return p.x1;
        }));
        var _yMin2 = (0, _d3Array.min)(projectedNodes.map(function (p) {
          return p.y0;
        }));
        var _yMax2 = (0, _d3Array.max)(projectedNodes.map(function (p) {
          return p.y1;
        }));

        var _projectionScaleX2 = (0, _d3Scale.scaleLinear)().domain([_xMin2, _xMax2]).range([margin.left, adjustedSize[0] - margin.right]);
        var _projectionScaleY2 = (0, _d3Scale.scaleLinear)().domain([_yMin2, _yMax2]).range([margin.top, adjustedSize[1] - margin.bottom]);
        projectedNodes.forEach(function (node) {
          node.x = _projectionScaleX2(node.x);
          node.y = _projectionScaleY2(node.y);
          node.x0 = _projectionScaleX2(node.x0);
          node.y0 = _projectionScaleY2(node.y0);
          node.x1 = _projectionScaleX2(node.x1);
          node.y1 = _projectionScaleY2(node.y1);
        });

        projectedEdges.forEach(function (edge) {
          if (edge.points) {
            edge.points.forEach(function (p) {
              p.x = _projectionScaleX2(p.x);
              p.y = _projectionScaleY2(p.y);
            });
          }
        });
      }

      projectedNodes.forEach(function (node) {
        node.nodeSize = nodeSizeAccessor(node);
      });

      projectedEdges.forEach(function (edge) {
        edge.width = edgeWidthAccessor(edge);
      });

      var legendSettings = void 0;

      if (currentProps.legend) {
        legendSettings = currentProps.legend;
        if (!legendSettings.legendGroups) {
          ///Something auto for networks
          var legendGroups = [{
            styleFn: currentProps.nodeStyle,
            type: "fill",
            items: []
          }];
          legendSettings.legendGroups = legendGroups;
        }
      }

      var networkFrameRender = {
        edges: {
          accessibleTransform: function accessibleTransform(data, i) {
            var edgeX = (data[i].source.x + data[i].target.x) / 2;
            var edgeY = (data[i].source.y + data[i].target.y) / 2;
            return _extends({ type: "frame-hover" }, data[i], { x: edgeX, y: edgeY });
          },
          data: projectedEdges,
          styleFn: (0, _dataFunctions.stringToFn)(edgeStyle, function () {
            return {};
          }, true),
          classFn: (0, _dataFunctions.stringToFn)(edgeClass, function () {
            return "";
          }, true),
          renderMode: (0, _dataFunctions.stringToFn)(edgeRenderMode, undefined, true),
          canvasRenderFn: canvasEdges && (0, _dataFunctions.stringToFn)(canvasEdges, undefined, true),
          renderKeyFn: currentProps.edgeRenderKey ? currentProps.edgeRenderKey : function (d) {
            return d._NWFEdgeKey || d.source.id + "-" + d.target.id;
          },
          behavior: _networkDrawing.drawEdges,
          projection: networkSettings.projection,
          type: edgeType,
          customMark: customEdgeIcon,
          networkType: networkSettings.type,
          direction: networkSettings.direction
        },
        nodes: {
          accessibleTransform: function accessibleTransform(data, i) {
            return _extends({
              type: "frame-hover"
            }, data[i], data[i].data || {});
          },
          data: projectedNodes,
          styleFn: nodeStyleFn,
          classFn: nodeClassFn,
          renderMode: nodeRenderModeFn,
          canvasRenderFn: nodeCanvasRenderFn,
          customMark: customNodeIcon,
          behavior: _networkDrawing.drawNodes,
          renderKeyFn: currentProps.nodeRenderKey
        }
      };

      var nodeLabelAnnotations = [];
      if (currentProps.nodeLabels && projectedNodes) {
        projectedNodes.forEach(function (node, nodei) {
          if (nodeLabels === true || nodeLabels && nodeLabels(node, nodei)) {
            var actualLabel = networkSettings.projection === "radial" && node.depth !== 0 ? (0, _networkDrawing.radialLabelGenerator)(node, nodei, nodeLabels === true ? nodeIDAccessor : nodeLabels, adjustedSize, networkSettings) : nodeLabels === true ? nodeIDAccessor(node, nodei) : nodeLabels(node, nodei);

            var nodeLabel = void 0;

            if (_react2.default.isValidElement(actualLabel)) {
              nodeLabel = {
                key: "node-label-" + nodei,
                type: "basic-node-label",
                x: node.x,
                y: node.y,
                element: actualLabel
              };
            } else {
              nodeLabel = {
                key: "node-label-" + nodei,
                className: "node-label",
                dx: 0,
                dy: 0,
                x: node.x,
                y: node.y,
                note: { label: actualLabel },
                connector: { end: "none" },
                type: _AnnotationLabel2.default,
                subject: { radius: nodeSizeAccessor(node) + 2 }
              };
            }

            nodeLabelAnnotations.push(nodeLabel);
          }
        });
      }

      var projectedXYPoints = void 0;
      var overlay = [];
      var areaBasedTypes = ["circlepack", "treemap", "partition", "chord"];
      if (hoverAnnotation && areaBasedTypes.find(function (d) {
        return d === networkSettings.type;
      }) || hoverAnnotation === "area") {
        if (hoverAnnotation !== "edge") {
          var renderedNodeOverlays = projectedNodes.map(function (d, i) {
            return _extends({
              overlayData: d
            }, customNodeIcon({
              d: d,
              i: i,
              transform: "translate(" + d.x + "," + d.y + ")",
              styleFn: function styleFn() {
                return { fill: "pink", opacity: 0 };
              }
            }).props);
          });

          overlay.push.apply(overlay, _toConsumableArray(renderedNodeOverlays));
        }
        if (hoverAnnotation !== "node") {
          projectedEdges.forEach(function (d, i) {
            // $FlowFixMe
            var generatedIcon = customEdgeIcon({
              d: d,
              i: i,
              transform: "translate(" + d.x + "," + d.y + ")",
              styleFn: function styleFn() {
                return { fill: "pink", opacity: 0 };
              }
            });
            if (generatedIcon) {
              overlay.push(_extends({
                overlayData: _extends({}, d, {
                  x: d.x || (d.source.x + d.target.x) / 2,
                  y: d.y || (d.source.y + d.target.y) / 2,
                  edge: true
                })
              }, generatedIcon.props));
            }
          });
        }
      } else if (hoverAnnotation === "edge" && edgePointHash[networkSettings.type]) {
        projectedXYPoints = projectedEdges.map(edgePointHash[networkSettings.type]);
      } else if (Array.isArray(hoverAnnotation) || hoverAnnotation === true || hoverAnnotation === "node") {
        projectedXYPoints = projectedNodes;
        if (changedData || networkSettingsChanged) projectedXYPoints = [].concat(_toConsumableArray(projectedNodes));
      } else if (hoverAnnotation === "all") {
        projectedXYPoints = [].concat(_toConsumableArray(projectedEdges.map(edgePointHash[networkSettings.type])), _toConsumableArray(projectedNodes));
      }

      this.setState({
        adjustedPosition: adjustedPosition,
        adjustedSize: adjustedSize,
        backgroundGraphics: currentProps.backgroundGraphics,
        foregroundGraphics: currentProps.foregroundGraphics,
        title: title,
        renderNumber: this.state.renderNumber + 1,
        projectedNodes: projectedNodes,
        projectedEdges: projectedEdges,
        projectedXYPoints: projectedXYPoints,
        overlay: overlay,
        nodeIDAccessor: nodeIDAccessor,
        sourceAccessor: sourceAccessor,
        targetAccessor: targetAccessor,
        nodeSizeAccessor: nodeSizeAccessor,
        edgeWidthAccessor: edgeWidthAccessor,
        margin: margin,
        legendSettings: legendSettings,
        networkFrameRender: networkFrameRender,
        nodeLabelAnnotations: nodeLabelAnnotations,
        graphSettings: _extends({}, networkSettings.graphSettings, networkSettings)
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _props = this.props,
          annotations = _props.annotations,
          annotationSettings = _props.annotationSettings,
          className = _props.className,
          customClickBehavior = _props.customClickBehavior,
          customDoubleClickBehavior = _props.customDoubleClickBehavior,
          customHoverBehavior = _props.customHoverBehavior,
          size = _props.size,
          matte = _props.matte,
          hoverAnnotation = _props.hoverAnnotation,
          beforeElements = _props.beforeElements,
          afterElements = _props.afterElements,
          interaction = _props.interaction,
          disableContext = _props.disableContext,
          canvasPostProcess = _props.canvasPostProcess,
          baseMarkProps = _props.baseMarkProps,
          useSpans = _props.useSpans,
          canvasNodes = _props.canvasNodes,
          canvasEdges = _props.canvasEdges,
          name = _props.name,
          downloadFields = _props.downloadFields,
          download = _props.download,
          additionalDefs = _props.additionalDefs,
          renderOrder = _props.renderOrder;
      var _state2 = this.state,
          backgroundGraphics = _state2.backgroundGraphics,
          foregroundGraphics = _state2.foregroundGraphics,
          projectedXYPoints = _state2.projectedXYPoints,
          margin = _state2.margin,
          legendSettings = _state2.legendSettings,
          adjustedPosition = _state2.adjustedPosition,
          adjustedSize = _state2.adjustedSize,
          networkFrameRender = _state2.networkFrameRender,
          nodeLabelAnnotations = _state2.nodeLabelAnnotations,
          overlay = _state2.overlay,
          projectedNodes = _state2.projectedNodes,
          projectedEdges = _state2.projectedEdges,
          title = _state2.title;


      var downloadButton = [];

      if (download && projectedNodes.length > 0) {
        downloadButton.push(_react2.default.createElement(_DownloadButton2.default, {
          key: "network-download-nodes",
          csvName: name + "-" + new Date().toJSON(),
          width: size[0],
          label: "Download Node List",
          data: (0, _downloadDataMapping.networkNodeDownloadMapping)({
            data: projectedNodes,
            fields: downloadFields
          })
        }));
      }
      if (download && projectedEdges.length > 0) {
        downloadButton.push(_react2.default.createElement(_DownloadButton2.default, {
          key: "network-download-edges",
          csvName: name + "-" + new Date().toJSON(),
          width: size[0],
          label: "Download Edge List",
          data: (0, _downloadDataMapping.networkEdgeDownloadMapping)({
            data: projectedEdges,
            fields: downloadFields
          })
        }));
      }

      var formattedOverlay = void 0;

      if (overlay && overlay.length > 0) {
        formattedOverlay = overlay;
      }

      return _react2.default.createElement(_Frame2.default, {
        name: "networkframe",
        renderPipeline: networkFrameRender,
        adjustedPosition: adjustedPosition,
        adjustedSize: adjustedSize,
        size: size,
        xScale: xScale,
        yScale: yScale,
        title: title,
        matte: matte,
        className: className,
        additionalDefs: additionalDefs,
        frameKey: "none",
        projectedCoordinateNames: projectedCoordinateNames,
        defaultSVGRule: this.defaultNetworkSVGRule,
        defaultHTMLRule: this.defaultNetworkHTMLRule,
        hoverAnnotation: Array.isArray(hoverAnnotation) ? hoverAnnotation : !!hoverAnnotation,
        annotations: [].concat(_toConsumableArray(annotations), _toConsumableArray(nodeLabelAnnotations)),
        annotationSettings: annotationSettings,
        legendSettings: legendSettings,
        interaction: interaction,
        customClickBehavior: customClickBehavior,
        customHoverBehavior: customHoverBehavior,
        customDoubleClickBehavior: customDoubleClickBehavior,
        points: projectedXYPoints,
        margin: margin,
        overlay: formattedOverlay,
        backgroundGraphics: backgroundGraphics,
        foregroundGraphics: foregroundGraphics,
        beforeElements: beforeElements,
        afterElements: afterElements,
        downloadButton: downloadButton,
        disableContext: disableContext,
        canvasPostProcess: canvasPostProcess,
        baseMarkProps: baseMarkProps,
        useSpans: !!useSpans,
        canvasRendering: !!(canvasNodes || canvasEdges),
        renderOrder: renderOrder,
        disableCanvasInteraction: true
      });
    }
  }]);

  return NetworkFrame;
}(_react2.default.Component), _class.defaultProps = {
  annotations: [],
  foregroundGraphics: [],
  annotationSettings: {},
  size: [500, 500],
  className: "",
  name: "networkframe",
  networkType: { type: "force", iterations: 500 },
  filterRenderedNodes: function filterRenderedNodes() {
    return true;
  }
}, _class.displayName = "NetworkFrame", _temp);
exports.default = NetworkFrame;
module.exports = exports['default'];