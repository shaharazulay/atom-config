"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.contouring = contouring;
exports.hexbinning = hexbinning;
exports.heatmapping = heatmapping;
exports.shapeBounds = shapeBounds;

var _react = require("react");

var _react2 = _interopRequireDefault(_react);

var _d3Contour = require("d3-contour");

var _d3Scale = require("d3-scale");

var _polylabel = require("@mapbox/polylabel");

var _polylabel2 = _interopRequireDefault(_polylabel);

var _d3Hexbin = require("d3-hexbin");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function contouring(_ref) {
  var areaType = _ref.areaType,
      data = _ref.data,
      finalXExtent = _ref.finalXExtent,
      finalYExtent = _ref.finalYExtent;

  var projectedAreas = [];
  if (!areaType.type) {
    areaType = { type: areaType };
  }

  var _areaType = areaType,
      _areaType$resolution = _areaType.resolution,
      resolution = _areaType$resolution === undefined ? 500 : _areaType$resolution,
      _areaType$thresholds = _areaType.thresholds,
      thresholds = _areaType$thresholds === undefined ? 10 : _areaType$thresholds,
      _areaType$bandwidth = _areaType.bandwidth,
      bandwidth = _areaType$bandwidth === undefined ? 20 : _areaType$bandwidth,
      neighborhood = _areaType.neighborhood;


  var xScale = (0, _d3Scale.scaleLinear)().domain(finalXExtent).rangeRound([0, resolution]).nice();
  var yScale = (0, _d3Scale.scaleLinear)().domain(finalYExtent).rangeRound([resolution, 0]).nice();

  data.forEach(function (contourData) {
    var contourProjectedAreas = (0, _d3Contour.contourDensity)().size([resolution, resolution]).x(function (d) {
      return xScale(d[0]);
    }).y(function (d) {
      return yScale(d[1]);
    }).thresholds(thresholds).bandwidth(bandwidth)(contourData._xyfCoordinates);

    if (neighborhood) {
      contourProjectedAreas = [contourProjectedAreas[0]];
    }

    contourProjectedAreas.forEach(function (area) {
      area.parentArea = contourData;
      area.bounds = [];
      area.coordinates.forEach(function (poly) {
        poly.forEach(function (subpoly, i) {
          poly[i] = subpoly.map(function (coordpair) {
            coordpair = [xScale.invert(coordpair[0]), yScale.invert(coordpair[1])];
            return coordpair;
          });
          //Only push bounds for the main poly, not its interior rings, otherwise you end up labeling interior cutouts
          if (i === 0) {
            area.bounds.push(shapeBounds(poly[i]));
          }
        });
      });
    });
    projectedAreas = [].concat(_toConsumableArray(projectedAreas), _toConsumableArray(contourProjectedAreas));
  });

  return projectedAreas;
}

function hexbinning(_ref2) {
  var areaType = _ref2.areaType,
      data = _ref2.data,
      finalXExtent = _ref2.finalXExtent,
      finalYExtent = _ref2.finalYExtent,
      size = _ref2.size,
      xScaleType = _ref2.xScaleType,
      yScaleType = _ref2.yScaleType;

  var projectedAreas = [];
  if (!areaType.type) {
    areaType = { type: areaType };
  }

  var _areaType2 = areaType,
      _areaType2$bins = _areaType2.bins,
      bins = _areaType2$bins === undefined ? 0.05 : _areaType2$bins,
      cellPx = _areaType2.cellPx,
      _areaType2$binValue = _areaType2.binValue,
      binValue = _areaType2$binValue === undefined ? function (d) {
    return d.length;
  } : _areaType2$binValue;


  var hexBinXScale = xScaleType.domain(finalXExtent).range([0, size[0]]);
  var hexBinYScale = yScaleType.domain(finalYExtent).range([0, size[1]]);

  var actualResolution = cellPx && cellPx / 2 || (bins > 1 ? 1 / bins : bins) * size[0] / 2;

  var hexbinner = (0, _d3Hexbin.hexbin)().x(function (d) {
    return hexBinXScale(d._xyfPoint[0]);
  }).y(function (d) {
    return hexBinYScale(d._xyfPoint[1]);
  }).radius(actualResolution).size(size);

  data.forEach(function (hexbinData) {
    var hexes = hexbinner(hexbinData._xyfCoordinates.map(function (d, i) {
      return _extends({
        _xyfPoint: d
      }, hexbinData.coordinates[i]);
    }));

    var hexMax = Math.max.apply(Math, _toConsumableArray(hexes.map(function (d) {
      return binValue(d);
    })));

    if (areaType.binMax) {
      areaType.binMax(hexMax);
    }

    //Option for blank hexe
    var hexBase = [[0, -1], [0.866, -0.5], [0.866, 0.5], [0, 1], [-0.866, 0.5], [-0.866, -0.5]];

    var hexWidth = hexBinXScale.invert(actualResolution) - finalXExtent[0];
    var hexHeight = hexBinYScale.invert(actualResolution) - finalYExtent[0];

    var hexacoordinates = hexBase.map(function (d) {
      return [d[0] * hexWidth, d[1] * hexHeight];
    });

    var hexbinProjectedAreas = hexes.map(function (d) {
      var hexValue = binValue(d);
      var gx = d.x;
      var gy = d.y;
      d.x = hexBinXScale.invert(d.x);
      d.y = hexBinYScale.invert(d.y);
      d.binItems = d;
      var percent = hexValue / hexMax;
      return {
        customMark: areaType.customMark && _react2.default.createElement(
          "g",
          { transform: "translate(" + gx + "," + (size[1] - gy) + ")" },
          areaType.customMark(_extends({}, d, {
            percent: percent,
            value: hexValue,
            radius: actualResolution,
            hexCoordinates: hexBase.map(function (d) {
              return [d[0] * actualResolution, d[1] * actualResolution];
            })
          }))
        ),
        _xyfCoordinates: hexacoordinates.map(function (p) {
          return [p[0] + d.x, p[1] + d.y];
        }),
        value: hexValue,
        percent: percent,
        data: d,
        parentArea: hexbinData,
        centroid: true
      };
    });
    projectedAreas = [].concat(_toConsumableArray(projectedAreas), _toConsumableArray(hexbinProjectedAreas));
  });

  return projectedAreas;
}

function heatmapping(_ref3) {
  var areaType = _ref3.areaType,
      data = _ref3.data,
      finalXExtent = _ref3.finalXExtent,
      finalYExtent = _ref3.finalYExtent,
      size = _ref3.size,
      xScaleType = _ref3.xScaleType,
      yScaleType = _ref3.yScaleType;

  var projectedAreas = [];
  if (!areaType.type) {
    areaType = { type: areaType };
  }

  var _areaType3 = areaType,
      _areaType3$binValue = _areaType3.binValue,
      binValue = _areaType3$binValue === undefined ? function (d) {
    return d.length;
  } : _areaType3$binValue,
      _areaType3$xBins = _areaType3.xBins,
      xBins = _areaType3$xBins === undefined ? areaType.yBins || 0.05 : _areaType3$xBins,
      _areaType3$yBins = _areaType3.yBins,
      yBins = _areaType3$yBins === undefined ? xBins : _areaType3$yBins,
      _areaType3$xCellPx = _areaType3.xCellPx,
      xCellPx = _areaType3$xCellPx === undefined ? !areaType.xBins && areaType.yCellPx : _areaType3$xCellPx,
      _areaType3$yCellPx = _areaType3.yCellPx,
      yCellPx = _areaType3$yCellPx === undefined ? !areaType.yBins && xCellPx : _areaType3$yCellPx;

  var xBinPercent = xBins < 1 ? xBins : 1 / xBins;
  var yBinPercent = yBins < 1 ? yBins : 1 / yBins;

  var heatmapBinXScale = xScaleType.domain(finalXExtent).range([0, size[0]]);
  var heatmapBinYScale = yScaleType.domain(finalYExtent).range([size[1], 0]);

  var actualResolution = [Math.ceil((xCellPx && xCellPx / size[0] || xBinPercent) * size[0] * 10) / 10, Math.ceil((yCellPx && yCellPx / size[1] || yBinPercent) * size[1] * 10) / 10];

  data.forEach(function (heatmapData) {
    var grid = [];
    var flatGrid = [];

    var cell = void 0;
    var gridColumn = void 0;

    for (var i = 0; i < size[0]; i += actualResolution[0]) {
      var x = heatmapBinXScale.invert(i);
      var x1 = heatmapBinXScale.invert(i + actualResolution[0]);

      gridColumn = [];
      grid.push(gridColumn);
      for (var j = 0; j < size[1]; j += actualResolution[1]) {
        var y = heatmapBinYScale.invert(j);
        var y1 = heatmapBinYScale.invert(j + actualResolution[1]);
        cell = {
          gx: i,
          gy: j,
          gw: actualResolution[0],
          gh: actualResolution[1],
          x: (x + x1) / 2,
          y: (y + y1) / 2,
          binItems: [],
          value: 0,
          _xyfCoordinates: [[x, y], [x1, y], [x1, y1], [x, y1]],
          parentArea: heatmapData
        };
        gridColumn.push(cell);
        flatGrid.push(cell);
      }
      gridColumn.push(cell);
    }
    grid.push(gridColumn);

    heatmapData._xyfCoordinates.forEach(function (d, di) {
      var xCoordinate = parseInt(heatmapBinXScale(d[0]) / actualResolution[0]);
      var yCoordinate = parseInt(heatmapBinYScale(d[1]) / actualResolution[1]);
      grid[xCoordinate][yCoordinate].binItems.push(heatmapData.coordinates[di]);
    });

    var maxValue = -Infinity;

    flatGrid.forEach(function (d) {
      d.value = binValue(d.binItems);
      maxValue = Math.max(maxValue, d.value);
    });

    if (areaType.binMax) {
      areaType.binMax(maxValue);
    }

    flatGrid.forEach(function (d) {
      d.percent = d.value / maxValue;
      d.customMark = areaType.customMark && _react2.default.createElement(
        "g",
        { transform: "translate(" + d.gx + "," + d.gy + ")" },
        areaType.customMark(d)
      );
    });

    projectedAreas = [].concat(_toConsumableArray(projectedAreas), flatGrid);
  });

  return projectedAreas;
}

function shapeBounds(coordinates) {
  var left = [Infinity, 0];
  var right = [-Infinity, 0];
  var top = [0, Infinity];
  var bottom = [0, -Infinity];
  coordinates.forEach(function (d) {
    left = d[0] < left[0] ? d : left;
    right = d[0] > right[0] ? d : right;
    bottom = d[1] > bottom[1] ? d : bottom;
    top = d[1] < top[1] ? d : top;
  });

  return { center: (0, _polylabel2.default)([coordinates]), top: top, left: left, right: right, bottom: bottom };
}