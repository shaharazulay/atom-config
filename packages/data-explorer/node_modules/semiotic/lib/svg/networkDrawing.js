"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.areaLink = exports.ribbonLink = exports.drawEdges = exports.drawNodes = exports.hierarchicalRectNodeGenerator = exports.radialLabelGenerator = exports.radialRectNodeGenerator = exports.chordNodeGenerator = exports.sankeyNodeGenerator = exports.wordcloudNodeGenerator = exports.dagreEdgeGenerator = exports.chordEdgeGenerator = exports.circleNodeGenerator = exports.radialCurveGenerator = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.topologicalSort = topologicalSort;
exports.circularAreaLink = circularAreaLink;

var _react = require("react");

var _react2 = _interopRequireDefault(_react);

var _semioticMark = require("semiotic-mark");

var _d3Glyphedge = require("d3-glyphedge");

var _d3Shape = require("d3-shape");

var _SvgHelper = require("./SvgHelper");

var _d3Interpolate = require("d3-interpolate");

var _d3Scale = require("d3-scale");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var horizontalDagreLineGenerator = (0, _d3Shape.line)().curve(_d3Shape.curveMonotoneX).x(function (d) {
  return d.x;
}).y(function (d) {
  return d.y;
});

var verticalDagreLineGenerator = (0, _d3Shape.line)().curve(_d3Shape.curveMonotoneY).x(function (d) {
  return d.x;
}).y(function (d) {
  return d.y;
});

function sankeyEdgeSort(a, b, direction) {
  if (a.circular && !b.circular) return -1;
  if (b.circular && !a.circular) return 1;
  var first = direction === "down" ? "y" : "x";
  var second = direction === "down" ? "x" : "y";

  return a.source[first] === b.source[first] ? a.sankeyWidth === b.sankeyWidth ? a.source[second] - b.source[second] : b.sankeyWidth - a.sankeyWidth : a.source[first] - b.source[first];
}

var sigmoidLinks = {
  horizontal: (0, _d3Shape.linkHorizontal)().x(function (d) {
    return d.x;
  }).y(function (d) {
    return d.y;
  }),
  vertical: (0, _d3Shape.linkVertical)().x(function (d) {
    return d.x;
  }).y(function (d) {
    return d.y;
  }),
  radial: _d3Glyphedge.d.lineArc
};

var customEdgeHashD = {
  curve: function curve(d) {
    var projection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "vertical";
    return sigmoidLinks[projection](d);
  },
  linearc: function linearc(d) {
    return _d3Glyphedge.d.lineArc(d);
  },
  ribbon: function ribbon(d) {
    return _d3Glyphedge.d.ribbon(d, d.width);
  },
  arrowhead: function arrowhead(d) {
    return _d3Glyphedge.d.arrowHead(d, d.target.nodeSize, d.width, d.width * 1.5);
  },
  halfarrow: function halfarrow(d) {
    return _d3Glyphedge.d.halfArrow(d, d.target.nodeSize, d.width, d.width * 1.5);
  },
  nail: function nail(d) {
    return _d3Glyphedge.d.nail(d, d.source.nodeSize);
  },
  comet: function comet(d) {
    return _d3Glyphedge.d.comet(d, d.target.nodeSize);
  },
  taffy: function taffy(d) {
    return _d3Glyphedge.d.taffy(d, d.source.nodeSize / 2, d.target.nodeSize / 2, (d.source.nodeSize + d.target.nodeSize) / 4);
  }
};

var radialCurveGenerator = exports.radialCurveGenerator = function radialCurveGenerator(size) {
  var radialCurve = (0, _d3Shape.linkRadial)().angle(function (d) {
    return d.x / size[0] * Math.PI * 2;
  }).radius(function (d) {
    return d.y;
  });

  return function (_ref) {
    var d = _ref.d,
        i = _ref.i,
        styleFn = _ref.styleFn,
        renderMode = _ref.renderMode,
        key = _ref.key,
        className = _ref.className,
        baseMarkProps = _ref.baseMarkProps;
    return _react2.default.createElement(_semioticMark.Mark, _extends({}, baseMarkProps, {
      key: key,
      transform: "translate(" + 50 + "," + (size[1] / 2 - 50) + ")",
      markType: "path",
      d: radialCurve(d),
      style: styleFn(d, i),
      renderMode: renderMode ? renderMode(d, i) : undefined,
      className: className,
      "aria-label": "Node " + d.id,
      tabIndex: -1
    }));
  };
};

var circleNodeGenerator = exports.circleNodeGenerator = function circleNodeGenerator(_ref2) {
  var d = _ref2.d,
      i = _ref2.i,
      styleFn = _ref2.styleFn,
      renderMode = _ref2.renderMode,
      key = _ref2.key,
      className = _ref2.className,
      transform = _ref2.transform,
      baseMarkProps = _ref2.baseMarkProps;

  //this is repetitious

  return _react2.default.createElement(_semioticMark.Mark, _extends({}, baseMarkProps, {
    key: key,
    transform: transform,
    markType: "rect",
    width: d.nodeSize * 2,
    height: d.nodeSize * 2,
    ry: d.nodeSize * 2,
    rx: d.nodeSize * 2,
    x: -d.nodeSize,
    y: -d.nodeSize,
    style: styleFn(d, i),
    renderMode: renderMode ? renderMode(d, i) : undefined,
    className: className,
    "aria-label": "Node " + d.id,
    tabIndex: -1
  }));
};

var chordEdgeGenerator = exports.chordEdgeGenerator = function chordEdgeGenerator(size) {
  return function (_ref3) {
    var d = _ref3.d,
        i = _ref3.i,
        styleFn = _ref3.styleFn,
        renderMode = _ref3.renderMode,
        key = _ref3.key,
        className = _ref3.className,
        baseMarkProps = _ref3.baseMarkProps;
    return _react2.default.createElement(_semioticMark.Mark, _extends({}, baseMarkProps, {
      renderMode: renderMode ? renderMode(d, i) : undefined,
      key: key,
      className: className,
      simpleInterpolate: true,
      transform: "translate(" + size[0] / 2 + "," + size[1] / 2 + ")",
      markType: "path",
      d: d.d,
      style: styleFn(d, i),
      "aria-label": "Connection from " + d.source.id + " to " + d.target.id,
      tabIndex: -1
    }));
  };
};

var dagreEdgeGenerator = exports.dagreEdgeGenerator = function dagreEdgeGenerator(direction) {
  var dagreLineGenerator = direction === "LR" || direction === "RL" ? horizontalDagreLineGenerator : verticalDagreLineGenerator;
  return function (_ref4) {
    var d = _ref4.d,
        i = _ref4.i,
        styleFn = _ref4.styleFn,
        renderMode = _ref4.renderMode,
        key = _ref4.key,
        className = _ref4.className,
        baseMarkProps = _ref4.baseMarkProps;

    if (d.ribbon || d.parallelEdges) {
      var ribbonGenerator = (0, _SvgHelper.linearRibbon)().x(function (p) {
        return p.x;
      }).y(function (p) {
        return p.y;
      }).r(function () {
        return d.weight || 1;
      });

      if (d.parallelEdges) {
        var sortedParallelEdges = d.parallelEdges.sort(function (a, b) {
          return b.weight - a.weight;
        });
        return _react2.default.createElement(
          "g",
          null,
          ribbonGenerator({
            points: d.points,
            multiple: d.parallelEdges
          }).map(function (ribbonD, ribbonI) {
            return _react2.default.createElement(_semioticMark.Mark, _extends({}, baseMarkProps, {
              renderMode: renderMode ? renderMode(d, i) : undefined,
              key: key + "-" + ribbonI,
              className: className,
              simpleInterpolate: true,
              markType: "path",
              d: ribbonD,
              style: styleFn(sortedParallelEdges[ribbonI], i),
              "aria-label": "Connection from " + d.source.id + " to " + d.target.id,
              tabIndex: -1
            }));
          })
        );
      }

      return _react2.default.createElement(_semioticMark.Mark, _extends({}, baseMarkProps, {
        renderMode: renderMode ? renderMode(d, i) : undefined,
        key: key,
        className: className,
        simpleInterpolate: true,
        markType: "path",
        d: ribbonGenerator(d.points),
        style: styleFn(d, i),
        "aria-label": "Connection from " + d.source.id + " to " + d.target.id,
        tabIndex: -1
      }));
    }

    return _react2.default.createElement(_semioticMark.Mark, _extends({}, baseMarkProps, {
      renderMode: renderMode ? renderMode(d, i) : undefined,
      key: key,
      className: className,
      simpleInterpolate: true,
      markType: "path",
      d: dagreLineGenerator(d.points),
      style: styleFn(d, i),
      "aria-label": "Connection from " + d.source.id + " to " + d.target.id,
      tabIndex: -1
    }));
  };
};

var wordcloudNodeGenerator = exports.wordcloudNodeGenerator = function wordcloudNodeGenerator(_ref5) {
  var d = _ref5.d,
      i = _ref5.i,
      styleFn = _ref5.styleFn,
      key = _ref5.key,
      className = _ref5.className,
      transform = _ref5.transform;

  var textStyle = styleFn(d, i);
  textStyle.fontSize = d.fontSize + "px";
  textStyle.fontWeight = d.fontWeight;
  textStyle.textAnchor = "middle";
  var textTransform = void 0,
      textY = void 0,
      textX = void 0;
  textTransform = "scale(" + d.scale + ")";

  if (!d.rotate) {
    textY = d.textHeight / 4;
    textTransform = "scale(" + d.scale + ")";
  } else {
    textTransform = "rotate(90) scale(" + d.scale + ")";
    textY = d.textHeight / 4;
  }

  return _react2.default.createElement(
    "g",
    { key: key, transform: transform },
    _react2.default.createElement(
      "text",
      {
        style: textStyle,
        y: textY,
        x: textX,
        transform: textTransform,
        className: className + " wordcloud",
        "aria-label": d._NWFText,
        role: "img",
        tabIndex: -1
      },
      d._NWFText
    )
  );
};

var sankeyNodeGenerator = exports.sankeyNodeGenerator = function sankeyNodeGenerator(_ref6) {
  var d = _ref6.d,
      i = _ref6.i,
      styleFn = _ref6.styleFn,
      renderMode = _ref6.renderMode,
      key = _ref6.key,
      className = _ref6.className,
      transform = _ref6.transform,
      baseMarkProps = _ref6.baseMarkProps;

  var height = d.direction !== "down" ? d.height : d.width;
  var width = d.direction !== "down" ? d.width : d.height;
  return _react2.default.createElement(_semioticMark.Mark, _extends({}, baseMarkProps, {
    renderMode: renderMode ? renderMode(d, i) : undefined,
    key: key,
    className: className,
    transform: transform,
    markType: "rect",
    height: height,
    width: width,
    x: -width / 2,
    y: -height / 2,
    rx: 0,
    ry: 0,
    style: styleFn(d),
    "aria-label": "Node " + d.id,
    tabIndex: -1
  }));
};

var chordNodeGenerator = exports.chordNodeGenerator = function chordNodeGenerator(size) {
  return function (_ref7) {
    var d = _ref7.d,
        i = _ref7.i,
        styleFn = _ref7.styleFn,
        renderMode = _ref7.renderMode,
        key = _ref7.key,
        className = _ref7.className,
        baseMarkProps = _ref7.baseMarkProps;
    return _react2.default.createElement(_semioticMark.Mark, _extends({}, baseMarkProps, {
      renderMode: renderMode ? renderMode(d, i) : undefined,
      key: key,
      className: className,
      transform: "translate(" + size[0] / 2 + "," + size[1] / 2 + ")",
      markType: "path",
      d: d.d,
      style: styleFn(d, i),
      "aria-label": "Node " + d.id,
      tabIndex: -1
    }));
  };
};

var radialRectNodeGenerator = exports.radialRectNodeGenerator = function radialRectNodeGenerator(size, center, type) {
  var radialArc = (0, _d3Shape.arc)();
  var _type$angleRange = type.angleRange,
      angleRange = _type$angleRange === undefined ? [0, 360] : _type$angleRange;

  var rangePct = angleRange.map(function (d) {
    return d / 360;
  });
  var rangeMod = rangePct[1] - rangePct[0];

  var adjustedPct = rangeMod < 1 ? (0, _d3Scale.scaleLinear)().domain([0, 1]).range(rangePct) : function (d) {
    return d;
  };

  return function (_ref8) {
    var d = _ref8.d,
        i = _ref8.i,
        styleFn = _ref8.styleFn,
        renderMode = _ref8.renderMode,
        key = _ref8.key,
        className = _ref8.className,
        baseMarkProps = _ref8.baseMarkProps;

    radialArc.innerRadius(d.y0 / 2).outerRadius(d.y1 / 2);

    return _react2.default.createElement(_semioticMark.Mark, _extends({}, baseMarkProps, {
      key: key,
      transform: "translate(" + center + ")",
      markType: "path",
      d: radialArc({
        startAngle: adjustedPct(d.x0 / size[0]) * Math.PI * 2,
        endAngle: adjustedPct(d.x1 / size[0]) * Math.PI * 2
      }),
      customTween: {
        fn: _SvgHelper.arcTweener,
        props: {
          startAngle: adjustedPct(d.x0 / size[0]) * Math.PI * 2,
          endAngle: adjustedPct(d.x1 / size[0]) * Math.PI * 2,
          innerRadius: d.y0 / 2,
          outerRadius: d.y1 / 2
        }
      },
      style: styleFn(d, i),
      renderMode: renderMode ? renderMode(d, i) : undefined,
      className: className,
      "aria-label": "Node " + d.id,
      tabIndex: -1
    }));
  };
};

var radialLabelGenerator = exports.radialLabelGenerator = function radialLabelGenerator(node, nodei, nodeIDAccessor, size) {
  var anglePct = (node.x1 + node.x0) / 2 / size[0];
  var nodeLabel = nodeIDAccessor(node, nodei);
  var labelRotate = anglePct > 0.5 ? anglePct * 360 + 90 : anglePct * 360 - 90;

  return _react2.default.createElement(
    "g",
    { transform: "rotate(" + labelRotate + ")" },
    typeof nodeLabel === "string" ? _react2.default.createElement(
      "text",
      { textAnchor: "middle", y: 5 },
      nodeLabel
    ) : nodeLabel
  );
};

var hierarchicalRectNodeGenerator = exports.hierarchicalRectNodeGenerator = function hierarchicalRectNodeGenerator(_ref9) {
  var d = _ref9.d,
      i = _ref9.i,
      styleFn = _ref9.styleFn,
      renderMode = _ref9.renderMode,
      key = _ref9.key,
      className = _ref9.className,
      baseMarkProps = _ref9.baseMarkProps;

  //this is repetitious
  return _react2.default.createElement(_semioticMark.Mark, _extends({}, baseMarkProps, {
    key: key,
    transform: "translate(0,0)",
    markType: "rect",
    width: d.x1 - d.x0,
    height: d.y1 - d.y0,
    x: d.x0,
    y: d.y0,
    rx: 0,
    ry: 0,
    style: styleFn(d, i),
    renderMode: renderMode ? renderMode(d, i) : undefined,
    className: className,
    "aria-label": "Node " + d.id,
    tabIndex: -1
  }));
};

var genericLineGenerator = function genericLineGenerator(d) {
  return "M" + d.source.x + "," + d.source.y + "L" + d.target.x + "," + d.target.y;
};

var drawNodes = exports.drawNodes = function drawNodes(_ref10) {
  var data = _ref10.data,
      renderKeyFn = _ref10.renderKeyFn,
      customMark = _ref10.customMark,
      styleFn = _ref10.styleFn,
      classFn = _ref10.classFn,
      renderMode = _ref10.renderMode,
      canvasDrawing = _ref10.canvasDrawing,
      canvasRenderFn = _ref10.canvasRenderFn,
      baseMarkProps = _ref10.baseMarkProps;

  var markGenerator = customMark;
  var renderedData = [];

  if (customMark && canvasRenderFn) {
    console.error("canvas rendering currently only supports generic circle nodes based on nodeSize");
  }

  data.forEach(function (d, i) {
    if (canvasRenderFn && canvasRenderFn(d, i) === true) {
      var canvasNode = {
        baseClass: "frame-piece",
        tx: d.x,
        ty: d.y,
        d: d,
        i: i,
        markProps: { markType: "circle", r: d.nodeSize },
        styleFn: styleFn,
        renderFn: renderMode,
        classFn: classFn
      };
      canvasDrawing.push(canvasNode);
    } else {
      renderedData.push(markGenerator({
        d: d,
        i: i,
        renderKeyFn: renderKeyFn,
        styleFn: styleFn,
        classFn: classFn,
        renderMode: renderMode,
        key: renderKeyFn ? renderKeyFn(d, i) : d.id || "node-" + i,
        className: "node " + classFn(d, i),
        transform: "translate(" + d.x + "," + d.y + ")",
        baseMarkProps: baseMarkProps
      }));
    }
  });
  return renderedData;
};

var drawEdges = exports.drawEdges = function drawEdges(_ref11) {
  var baseData = _ref11.data,
      renderKeyFn = _ref11.renderKeyFn,
      customMark = _ref11.customMark,
      styleFn = _ref11.styleFn,
      classFn = _ref11.classFn,
      renderMode = _ref11.renderMode,
      canvasRenderFn = _ref11.canvasRenderFn,
      canvasDrawing = _ref11.canvasDrawing,
      type = _ref11.type,
      baseMarkProps = _ref11.baseMarkProps,
      networkType = _ref11.networkType,
      direction = _ref11.direction,
      projection = _ref11.projection;

  var data = networkType === "sankey" ? baseData.sort(function (a, b) {
    return sankeyEdgeSort(a, b, direction);
  }) : baseData;

  var dGenerator = genericLineGenerator;
  var renderedData = [];
  if (customMark) {
    data.forEach(function (d, i) {
      var renderedCustomMark = customMark({
        d: d,
        i: i,
        renderKeyFn: renderKeyFn,
        styleFn: styleFn,
        classFn: classFn,
        renderMode: renderMode,
        key: renderKeyFn ? renderKeyFn(d, i) : "edge-" + i,
        className: classFn(d, i) + " edge",
        transform: "translate(" + d.x + "," + d.y + ")",
        baseMarkProps: baseMarkProps
      });
      if (renderedCustomMark && renderedCustomMark.props && (renderedCustomMark.props.markType !== "path" || renderedCustomMark.props.d)) {
        renderedData.push(renderedCustomMark);
      }
    });
  } else {
    if (type) {
      if (typeof type === "function") {
        dGenerator = type;
      } else if (customEdgeHashD[type]) {
        dGenerator = function dGenerator(d) {
          return customEdgeHashD[type](d, projection);
        };
      }
    }
    data.forEach(function (d, i) {
      var renderedD = dGenerator(d);

      if (renderedD && canvasRenderFn && canvasRenderFn(d, i) === true) {
        var canvasNode = {
          baseClass: "frame-piece",
          tx: d.x,
          ty: d.y,
          d: d,
          i: i,
          markProps: { markType: "path", d: renderedD },
          styleFn: styleFn,
          renderFn: renderMode,
          classFn: classFn
        };
        canvasDrawing.push(canvasNode);
      } else if (renderedD) {
        renderedData.push(_react2.default.createElement(_semioticMark.Mark, _extends({}, baseMarkProps, {
          key: renderKeyFn ? renderKeyFn(d, i) : "edge-" + i,
          markType: "path",
          renderMode: renderMode ? renderMode(d, i) : undefined,
          className: classFn(d) + " edge",
          d: renderedD,
          style: styleFn(d, i),
          tabIndex: -1,
          role: "img",
          "aria-label": "connection from " + d.source.id + " to " + d.target.id
        })));
      }
    });
  }

  return renderedData;
};

function topologicalSort(nodesArray, edgesArray) {
  // adapted from https://simplapi.wordpress.com/2015/08/19/detect-graph-cycle-in-javascript/
  var nodes = [];
  var nodeHash = {};
  edgesArray.forEach(function (edge) {
    if (!edge.source.id || !edge.target.id) {
      return false;
    }
    if (!nodeHash[edge.source.id]) {
      nodeHash[edge.source.id] = { _id: edge.source.id, links: [] };
      nodes.push(nodeHash[edge.source.id]);
    }
    if (!nodeHash[edge.target.id]) {
      nodeHash[edge.target.id] = { _id: edge.target.id, links: [] };
      nodes.push(nodeHash[edge.target.id]);
    }
    nodeHash[edge.source.id].links.push(edge.target.id);
  });

  // Test if a node got any icoming edge
  function hasIncomingEdge(list, node) {
    for (var i = 0, l = list.length; i < l; ++i) {
      if (list[i].links.indexOf(node._id) !== -1) {
        return true;
      }
    }
    return false;
  }

  // Kahn Algorithm
  var L = [],
      S = nodes.filter(function (node) {
    return !hasIncomingEdge(nodes, node);
  });

  var n = null;

  while (S.length) {
    // Remove a node n from S
    n = S.pop();
    // Add n to tail of L
    L.push(n);

    var i = n.links.length;
    while (i--) {
      // Getting the node associated to the current stored id in links
      var m = nodes[nodes.map(function (d) {
        return d._id;
      }).indexOf(n.links[i])];

      // Remove edge e from the graph
      n.links.pop();

      if (!hasIncomingEdge(nodes, m)) {
        S.push(m);
      }
    }
  }

  // If any of them still got links, there is cycle somewhere
  var nodeWithEdge = nodes.find(function (node) {
    return node.links.length !== 0;
  });

  return nodeWithEdge ? null : L;
}
var curvature = 0.5;

var ribbonLink = exports.ribbonLink = function ribbonLink(d) {
  var diff = d.direction === "down" ? Math.abs(d.target.y - d.source.y) : Math.abs(d.source.x - d.target.x);
  // const halfWidth = d.width / 2
  var testCoordinates = d.direction === "down" ? [{
    x: d.y0,
    y: d.source.y
  }, {
    x: d.y0,
    y: d.source.y + diff / 3
  }, {
    x: d.y1,
    y: d.target.y - diff / 3
  }, {
    x: d.y1,
    y: d.target.y
  }] : [{
    x: d.source.x0,
    y: d.y0
  }, {
    x: d.source.x0 + diff / 3,
    y: d.y0
  }, {
    x: d.target.x0 - diff / 3,
    y: d.y1
  }, {
    x: d.target.x0,
    y: d.y1
  }];

  var linkGenerator = (0, _SvgHelper.linearRibbon)().x(function (d) {
    return d.x;
  }).y(function (d) {
    return d.y;
  }).r(function () {
    return d.sankeyWidth / 2;
  });

  return linkGenerator(testCoordinates);
};

var areaLink = exports.areaLink = function areaLink(d) {
  var x0 = void 0,
      x1 = void 0,
      x2 = void 0,
      x3 = void 0,
      y0 = void 0,
      y1 = void 0,
      xi = void 0,
      y2 = void 0,
      y3 = void 0;

  if (d.direction === "down") {
    x0 = d.y0 - d.sankeyWidth / 2;
    x1 = d.y1 - d.sankeyWidth / 2;
    x2 = d.y1 + d.sankeyWidth / 2;
    x3 = d.y0 + d.sankeyWidth / 2;
    y0 = d.source.y1;
    y1 = d.target.y0;
    xi = (0, _d3Interpolate.interpolateNumber)(y0, y1);
    y2 = xi(curvature);
    y3 = xi(1 - curvature);

    return "M" + x0 + "," + y0 + "C" + x0 + "," + y2 + " " + x1 + "," + y3 + " " + x1 + "," + y1 + "L" + x2 + "," + y1 + "C" + x2 + "," + y3 + " " + x3 + "," + y2 + " " + x3 + "," + y0 + "Z";
  }
  ;x0 = d.source.x1, // eslint-disable-line no-sequences
  x1 = d.target.x0, xi = (0, _d3Interpolate.interpolateNumber)(x0, x1), x2 = xi(curvature), x3 = xi(1 - curvature), y0 = d.y0 - d.sankeyWidth / 2, y1 = d.y1 - d.sankeyWidth / 2, y2 = d.y1 + d.sankeyWidth / 2, y3 = d.y0 + d.sankeyWidth / 2;

  return "M" + x0 + "," + y0 + "C" + x2 + "," + y0 + " " + x3 + "," + y1 + " " + x1 + "," + y1 + "L" + x1 + "," + y2 + "C" + x3 + "," + y2 + " " + x2 + "," + y3 + " " + x0 + "," + y3 + "Z";
};

function circularAreaLink(link) {
  var linkGenerator = (0, _SvgHelper.linearRibbon)().x(function (d) {
    return d.x;
  }).y(function (d) {
    return d.y;
  }).r(function () {
    return link.sankeyWidth / 2;
  });

  var xyForLink = link.direction === "down" ? [{
    x: link.circularPathData.sourceY,
    y: link.circularPathData.sourceX
  }, {
    x: link.circularPathData.sourceY,
    y: link.circularPathData.leftFullExtent
  }, {
    x: link.circularPathData.verticalFullExtent,
    y: link.circularPathData.leftFullExtent
  }, {
    x: link.circularPathData.verticalFullExtent,
    y: link.circularPathData.rightFullExtent
  }, {
    x: link.circularPathData.targetY,
    y: link.circularPathData.rightFullExtent
  }, {
    x: link.circularPathData.targetY,
    y: link.circularPathData.targetX
  }] : [{
    x: link.circularPathData.sourceX,
    y: link.circularPathData.sourceY
  }, {
    x: link.circularPathData.leftFullExtent,
    y: link.circularPathData.sourceY
  }, {
    x: link.circularPathData.leftFullExtent,
    y: link.circularPathData.verticalFullExtent
  }, {
    x: link.circularPathData.rightFullExtent,
    y: link.circularPathData.verticalFullExtent
  }, {
    x: link.circularPathData.rightFullExtent,
    y: link.circularPathData.targetY
  }, {
    x: link.circularPathData.targetX,
    y: link.circularPathData.targetY
  }];

  return linkGenerator(xyForLink);
}