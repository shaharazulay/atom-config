"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.svgHullEncloseAnnotation = exports.svgEncloseAnnotation = exports.svgRectEncloseAnnotation = exports.htmlTooltipAnnotation = exports.svgAreaAnnotation = exports.svgLineAnnotation = exports.svgBoundsAnnotation = exports.svgYAnnotation = exports.svgXAnnotation = exports.basicReactAnnotation = exports.svgXYAnnotation = exports.svgHighlight = exports.svgVerticalPointsAnnotation = exports.svgHorizontalPointsAnnotation = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = require("react");

var _react2 = _interopRequireDefault(_react);

var _semioticMark = require("semiotic-mark");

var _Annotation = require("../Annotation");

var _Annotation2 = _interopRequireDefault(_Annotation);

var _AnnotationCalloutRect = require("react-annotation/lib/Types/AnnotationCalloutRect");

var _AnnotationCalloutRect2 = _interopRequireDefault(_AnnotationCalloutRect);

var _AnnotationXYThreshold = require("react-annotation/lib/Types/AnnotationXYThreshold");

var _AnnotationXYThreshold2 = _interopRequireDefault(_AnnotationXYThreshold);

var _d3Shape = require("d3-shape");

var _d3Hierarchy = require("d3-hierarchy");

var _d3Array = require("d3-array");

var _baseRules = require("./baseRules");

var _SpanOrDiv = require("../SpanOrDiv");

var _SpanOrDiv2 = _interopRequireDefault(_SpanOrDiv);

var _multiAccessorUtils = require("../data/multiAccessorUtils");

var _general = require("../visualizationLayerBehavior/general");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var pointsAlong = function pointsAlong(along) {
  return function (_ref) {
    var d = _ref.d,
        lines = _ref.lines,
        points = _ref.points,
        xScale = _ref.xScale,
        yScale = _ref.yScale,
        pointStyle = _ref.pointStyle;

    var alongScale = along === "x" ? xScale : yScale;
    along = along === "yTop" && d.yMiddle ? "yMiddle" : along;
    if (d && d[along]) {
      var _d$threshold = d.threshold,
          threshold = _d$threshold === undefined ? 1 : _d$threshold,
          _d$r = d.r,
          r = _d$r === undefined ? function () {
        return 4;
      } : _d$r,
          _d$styleFn = d.styleFn,
          styleFn = _d$styleFn === undefined ? pointStyle : _d$styleFn;

      var foundPoints = [];

      var halfThreshold = threshold / 2;

      if (lines && lines.length > 0) {
        lines.forEach(function (linedata) {
          var linePoints = linedata.data.filter(function (p) {
            var pAlong = alongScale(p[along]);
            var dAlong = alongScale(d[along]);

            return pAlong <= dAlong + halfThreshold && pAlong >= dAlong - halfThreshold;
          });
          foundPoints.push.apply(foundPoints, _toConsumableArray(linePoints));
        });
      }

      if (points && points.length > 0) {
        var pointPoints = points.filter(function (p) {
          var pAlong = alongScale(p[along]);
          var dAlong = alongScale(d[along]);

          return pAlong <= dAlong + halfThreshold && pAlong >= dAlong - halfThreshold;
        });
        foundPoints.push.apply(foundPoints, _toConsumableArray(pointPoints));
      }

      return foundPoints.map(function (p, i) {
        return _react2.default.createElement("circle", {
          key: "found-circle-" + i,
          r: r(p, i),
          style: styleFn(p, i),
          cx: xScale(p.xMiddle || p.x),
          cy: yScale(p.yMiddle || p.yTop)
        });
      });
    }
    return null;
  };
};

var svgHorizontalPointsAnnotation = exports.svgHorizontalPointsAnnotation = pointsAlong("yTop");
var svgVerticalPointsAnnotation = exports.svgVerticalPointsAnnotation = pointsAlong("x");

var svgHighlight = exports.svgHighlight = function svgHighlight(_ref2) {
  var d = _ref2.d,
      i = _ref2.i,
      _ref2$points = _ref2.points,
      points = _ref2$points === undefined ? { data: [] } : _ref2$points,
      _ref2$lines = _ref2.lines,
      lines = _ref2$lines === undefined ? { data: [] } : _ref2$lines,
      _ref2$areas = _ref2.areas,
      areas = _ref2$areas === undefined ? { data: [] } : _ref2$areas,
      idAccessor = _ref2.idAccessor,
      xScale = _ref2.xScale,
      yScale = _ref2.yScale;

  var dID = void 0;
  var baseID = idAccessor(_extends({}, d, d.data), i);
  if (baseID !== undefined) {
    dID = baseID;
  } else if (d.parentLine && idAccessor(d.parentLine, i) !== undefined) {
    dID = idAccessor(d.parentLine, i);
  } else if (d.parentArea && idAccessor(d.parentArea, i) !== undefined) {
    dID = idAccessor(d.parentArea, i);
  }

  var foundPoints = points.data.filter(function (p, q) {
    return idAccessor(_extends({}, p, p.data), q) === dID;
  }).map(function (p, q) {
    return _react2.default.createElement("circle", {
      key: "highlight-point-" + q,
      cx: xScale(p.x),
      cy: yScale(p.y),
      r: 5,
      fill: "none",
      stroke: "black",
      strokeWidth: 2,
      style: typeof d.style === "function" ? d.style(p.data, q) : d.style,
      className: "highlight-annotation " + (d.class && typeof d.class === "function" && d.class(p.data, q) || d.class && d.class || "")
    });
  });

  var lineGenerator = (0, _d3Shape.area)().x(function (p) {
    return xScale(p.x);
  }).y0(function (p) {
    return yScale(p.yBottom);
  }).y1(function (p) {
    return yScale(p.yTop);
  });

  var actualInterpolator = typeof lines.type.interpolator === "string" ? _general.curveHash[lines.type.interpolator] : lines.type.interpolator;

  if (actualInterpolator) {
    lineGenerator.curve(actualInterpolator);
  }

  var foundLines = lines.data.filter(function (p, q) {
    return idAccessor(p, q) === dID;
  }).map(function (p, q) {
    return _react2.default.createElement("path", {
      className: "highlight-annotation " + (d.class && typeof d.class === "function" && d.class(p, q) || d.class && d.class || ""),
      key: "highlight-area-" + q,
      d: lineGenerator(p.data),
      fill: "none",
      stroke: "black",
      strokeWidth: 1,
      style: typeof d.style === "function" ? d.style(p, q) : d.style
    });
  });

  var foundAreas = areas.data.filter(function (p, q) {
    return idAccessor(p, q) === dID;
  }).map(function (p, q) {
    return _react2.default.createElement("path", {
      className: "highlight-annotation " + (d.class && typeof d.class === "function" && d.class(p, q) || d.class && d.class || ""),
      key: "highlight-area-" + q,
      d: "M" + p.coordinates.join("L"),
      fill: "none",
      stroke: "black",
      strokeWidth: 1,
      style: typeof d.style === "function" ? d.style(p, q) : d.style
    });
  });

  return [].concat(_toConsumableArray(foundAreas), _toConsumableArray(foundLines), _toConsumableArray(foundPoints));
};

var svgXYAnnotation = exports.svgXYAnnotation = function svgXYAnnotation(_ref3) {
  var screenCoordinates = _ref3.screenCoordinates,
      i = _ref3.i,
      d = _ref3.d;

  var inlineStyle = void 0;
  if (d.color) inlineStyle = { fill: d.color };

  var laLine = _react2.default.createElement(_semioticMark.Mark, {
    className: "annotation " + d.type + " " + (d.className || "") + " ",
    key: "annotationpoint" + i,
    markType: "circle",
    cx: screenCoordinates[0],
    cy: screenCoordinates[1],
    forceUpdate: true,
    style: inlineStyle,
    fill: "none",
    stroke: "black",
    r: 5
  });
  var laLabel = void 0;
  if (d.type === "xy") {
    laLabel = _react2.default.createElement(
      _semioticMark.Mark,
      {
        markType: "text",
        key: d.label + "annotationtext" + i,
        forceUpdate: true,
        x: screenCoordinates[0],
        y: 10 + screenCoordinates[1],
        className: "annotation annotation-xy-label " + (d.className || "") + " "
      },
      d.label
    );
  }

  return [laLine, laLabel];
};

var basicReactAnnotation = exports.basicReactAnnotation = function basicReactAnnotation(_ref4) {
  var screenCoordinates = _ref4.screenCoordinates,
      d = _ref4.d,
      i = _ref4.i;

  var noteData = _extends({
    dx: 0,
    dy: 0,
    note: { label: d.label },
    connector: { end: "arrow" }
  }, d, {
    type: d.type,
    screenCoordinates: screenCoordinates
  });

  noteData.x = noteData.fixedX ? noteData.fixedX : screenCoordinates[0];
  noteData.y = noteData.fixedY ? noteData.fixedY : screenCoordinates[1];

  return _react2.default.createElement(_Annotation2.default, { key: d.key || "annotation-" + i, noteData: noteData });
};

var svgXAnnotation = exports.svgXAnnotation = function svgXAnnotation(_ref5) {
  var screenCoordinates = _ref5.screenCoordinates,
      d = _ref5.d,
      i = _ref5.i,
      adjustedSize = _ref5.adjustedSize;

  var noteData = _extends({
    dx: 50,
    dy: 20,
    y: 0,
    note: { label: d.label },
    connector: { end: "arrow" }
  }, d, {
    type: _AnnotationXYThreshold2.default,
    x: screenCoordinates[0],
    subject: {
      x: screenCoordinates[0],
      y1: 0,
      y2: adjustedSize[1]
    }
  });
  return _react2.default.createElement(_Annotation2.default, { key: d.key || "annotation-" + i, noteData: noteData });
};

var svgYAnnotation = exports.svgYAnnotation = function svgYAnnotation(_ref6) {
  var screenCoordinates = _ref6.screenCoordinates,
      d = _ref6.d,
      i = _ref6.i,
      adjustedSize = _ref6.adjustedSize,
      adjustedPosition = _ref6.adjustedPosition;

  var xPosition = i * 25;

  var noteData = _extends({
    dx: 50,
    dy: -20,
    x: xPosition,
    note: { label: d.label },
    connector: { end: "arrow" }
  }, d, {
    type: _AnnotationXYThreshold2.default,
    y: screenCoordinates[1],
    subject: {
      y: screenCoordinates[1],
      x1: 0,
      x2: adjustedSize[0] + adjustedPosition[0]
    }
  });
  return _react2.default.createElement(_Annotation2.default, { key: d.key || "annotation-" + i, noteData: noteData });
};

var svgBoundsAnnotation = exports.svgBoundsAnnotation = function svgBoundsAnnotation(_ref7) {
  var d = _ref7.d,
      i = _ref7.i,
      adjustedSize = _ref7.adjustedSize,
      xAccessor = _ref7.xAccessor,
      yAccessor = _ref7.yAccessor,
      xScale = _ref7.xScale,
      yScale = _ref7.yScale;

  var startXValue = (0, _multiAccessorUtils.findFirstAccessorValue)(xAccessor, d.bounds[0]);
  var startYValue = (0, _multiAccessorUtils.findFirstAccessorValue)(yAccessor, d.bounds[0]);
  var endXValue = (0, _multiAccessorUtils.findFirstAccessorValue)(xAccessor, d.bounds[1]);
  var endYValue = (0, _multiAccessorUtils.findFirstAccessorValue)(yAccessor, d.bounds[1]);

  var x0Position = startXValue ? xScale(startXValue) : 0;
  var y0Position = startYValue ? yScale(startYValue) : adjustedSize[1];
  var x1Position = endXValue ? xScale(endXValue) : adjustedSize[0];
  var y1Position = endYValue ? yScale(endYValue) : 0;

  var noteData = _extends({
    dx: 250,
    dy: -20,
    note: { label: d.label },
    connector: { end: "arrow" }
  }, d, {
    type: _AnnotationCalloutRect2.default,
    x: Math.min(x0Position, x1Position),
    y: Math.min(y0Position, y1Position),
    subject: {
      width: Math.abs(x1Position - x0Position),
      height: Math.abs(y0Position - y1Position)
    }
  });
  return _react2.default.createElement(_Annotation2.default, { key: d.key || "annotation-" + i, noteData: noteData });
};

var svgLineAnnotation = exports.svgLineAnnotation = function svgLineAnnotation(_ref8) {
  var d = _ref8.d,
      i = _ref8.i,
      screenCoordinates = _ref8.screenCoordinates;

  var lineGenerator = (0, _d3Shape.line)().x(function (p) {
    return p[0];
  }).y(function (p) {
    return p[1];
  });
  var lineD = lineGenerator(screenCoordinates);
  var laLine = _react2.default.createElement(_semioticMark.Mark, {
    key: d.label + "annotationline" + i,
    markType: "path",
    d: lineD,
    className: "annotation annotation-line " + (d.className || "") + " "
  });

  var laLabel = _react2.default.createElement(
    _semioticMark.Mark,
    {
      markType: "text",
      key: d.label + "annotationlinetext" + i,
      x: (screenCoordinates[0][0] + screenCoordinates[1][0]) / 2,
      y: (screenCoordinates[0][1] + screenCoordinates[1][1]) / 2,
      className: "annotation annotation-line-label " + (d.className || "") + " "
    },
    d.label
  );

  return [laLine, laLabel];
};

var svgAreaAnnotation = exports.svgAreaAnnotation = function svgAreaAnnotation(_ref9) {
  var d = _ref9.d,
      i = _ref9.i,
      xScale = _ref9.xScale,
      xAccessor = _ref9.xAccessor,
      yScale = _ref9.yScale,
      yAccessor = _ref9.yAccessor,
      annotationLayer = _ref9.annotationLayer;

  var mappedCoordinates = "M" + d.coordinates.map(function (p) {
    return [xScale((0, _multiAccessorUtils.findFirstAccessorValue)(xAccessor, p)), yScale((0, _multiAccessorUtils.findFirstAccessorValue)(yAccessor, p))];
  }).join("L") + "Z";
  var xBounds = (0, _d3Array.extent)(d.coordinates.map(function (p) {
    return xScale((0, _multiAccessorUtils.findFirstAccessorValue)(xAccessor, p));
  }));
  var yBounds = (0, _d3Array.extent)(d.coordinates.map(function (p) {
    return yScale((0, _multiAccessorUtils.findFirstAccessorValue)(yAccessor, p));
  }));
  var xCenter = (xBounds[0] + xBounds[1]) / 2;
  var yCenter = (yBounds[0] + yBounds[1]) / 2;

  var laLine = _react2.default.createElement(_semioticMark.Mark, {
    key: d.label + "-annotationarea-" + i,
    markType: "path",
    transform: "translate(" + annotationLayer.position + ")",
    d: mappedCoordinates,
    className: "annotation annotation-area " + (d.className || "") + " "
  });

  var laLabel = _react2.default.createElement(
    _semioticMark.Mark,
    {
      markType: "text",
      key: d.label + "-annotationtext-" + i,
      forceUpdate: true,
      x: xCenter,
      y: yCenter,
      transform: "translate(" + annotationLayer.position + ")",
      className: "annotation annotation-area-label " + (d.className || "") + " ",
      style: { textAnchor: "middle" }
    },
    d.label
  );

  return [laLine, laLabel];
};

var htmlTooltipAnnotation = exports.htmlTooltipAnnotation = function htmlTooltipAnnotation(_ref10) {
  var content = _ref10.content,
      screenCoordinates = _ref10.screenCoordinates,
      i = _ref10.i,
      d = _ref10.d,
      useSpans = _ref10.useSpans;

  //To string because React gives a DOM error if it gets a date

  return _react2.default.createElement(
    _SpanOrDiv2.default,
    {
      span: useSpans,
      key: "xylabel-" + i,
      className: "annotation annotation-xy-label " + (d.className || "") + " ",
      style: {
        position: "absolute",
        top: screenCoordinates[1] + "px",
        left: screenCoordinates[0] + "px"
      }
    },
    content
  );
};

var svgRectEncloseAnnotation = exports.svgRectEncloseAnnotation = function svgRectEncloseAnnotation(_ref11) {
  var d = _ref11.d,
      i = _ref11.i,
      screenCoordinates = _ref11.screenCoordinates;

  var bboxNodes = screenCoordinates.map(function (p) {
    return {
      x0: p.x0 = p[0],
      x1: p.x1 = p[0],
      y0: p.y0 = p[1],
      y1: p.y1 = p[1]
    };
  });

  return (0, _baseRules.rectangleEnclosure)({ bboxNodes: bboxNodes, d: d, i: i });
};

var svgEncloseAnnotation = exports.svgEncloseAnnotation = function svgEncloseAnnotation(_ref12) {
  var screenCoordinates = _ref12.screenCoordinates,
      d = _ref12.d;

  var circle = (0, _d3Hierarchy.packEnclose)(screenCoordinates.map(function (p) {
    return { x: p[0], y: p[1], r: 2 };
  }));

  return (0, _baseRules.circleEnclosure)({ d: d, circle: circle });
};

var svgHullEncloseAnnotation = exports.svgHullEncloseAnnotation = function svgHullEncloseAnnotation(_ref13) {
  var screenCoordinates = _ref13.screenCoordinates,
      d = _ref13.d,
      i = _ref13.i;

  return (0, _baseRules.hullEnclosure)({ points: screenCoordinates, d: d, i: i });
};