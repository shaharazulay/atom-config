"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.svgHighlightRule = exports.svgHullEncloseRule = exports.svgRectEncloseRule = exports.svgEncloseRule = exports.svgReactAnnotationRule = exports.svgNodeRule = exports.htmlFrameHoverRule = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = require("react");

var _react2 = _interopRequireDefault(_react);

var _Annotation = require("../Annotation");

var _Annotation2 = _interopRequireDefault(_Annotation);

var _AnnotationCalloutCircle = require("react-annotation/lib/Types/AnnotationCalloutCircle");

var _AnnotationCalloutCircle2 = _interopRequireDefault(_AnnotationCalloutCircle);

var _d3Hierarchy = require("d3-hierarchy");

var _baseRules = require("./baseRules");

var _SpanOrDiv = require("../SpanOrDiv");

var _SpanOrDiv2 = _interopRequireDefault(_SpanOrDiv);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var htmlFrameHoverRule = exports.htmlFrameHoverRule = function htmlFrameHoverRule(_ref) {
  var baseD = _ref.d,
      i = _ref.i,
      tooltipContent = _ref.tooltipContent,
      useSpans = _ref.useSpans,
      nodes = _ref.nodes,
      edges = _ref.edges,
      nodeIDAccessor = _ref.nodeIDAccessor;

  var d = baseD.x && baseD.y ? baseD : baseD.edge ? _extends({}, edges.find(function (p) {
    return nodeIDAccessor(p.source) === nodeIDAccessor(baseD.source) && nodeIDAccessor(p.target) === nodeIDAccessor(baseD.target);
  }) || {}, baseD) : nodes.find(function (p) {
    return nodeIDAccessor(p) === baseD.id;
  });

  if (!d) return null;

  var content = d.edge ? _react2.default.createElement(
    _SpanOrDiv2.default,
    { span: useSpans, className: "tooltip-content" },
    _react2.default.createElement(
      "p",
      { key: "html-annotation-content-1" },
      (d.source || d.edge.source).id,
      " to ",
      (d.source || d.edge.source).id
    )
  ) : _react2.default.createElement(
    _SpanOrDiv2.default,
    { span: useSpans, className: "tooltip-content" },
    _react2.default.createElement(
      "p",
      { key: "html-annotation-content-1" },
      d.id
    ),
    _react2.default.createElement(
      "p",
      { key: "html-annotation-content-2" },
      "Degree: ",
      d.degree
    )
  );

  if (d.type === "frame-hover" && tooltipContent) {
    content = tooltipContent(d);
  }

  return _react2.default.createElement(
    _SpanOrDiv2.default,
    {
      span: useSpans,
      key: "xylabel" + i,
      className: "annotation annotation-network-label " + (d.className || ""),
      style: {
        position: "absolute",
        top: d.y + "px",
        left: d.x + "px"
      }
    },
    content
  );
};

var svgNodeRule = exports.svgNodeRule = function svgNodeRule(_ref2) {
  var d = _ref2.d,
      i = _ref2.i,
      nodeSizeAccessor = _ref2.nodeSizeAccessor;

  if (!d) {
    return null;
  }
  var noteData = _extends({
    dx: d.dx || -25,
    dy: d.dy || -25,
    x: d.x,
    y: d.y,
    note: { label: d.label },
    connector: { end: "arrow" }
  }, d, {
    type: _AnnotationCalloutCircle2.default,
    subject: {
      radius: d.radius || d.radius || nodeSizeAccessor(d)
    }
  });
  return _react2.default.createElement(_Annotation2.default, { key: d.key || "annotation-" + i, noteData: noteData });
};

var svgReactAnnotationRule = exports.svgReactAnnotationRule = function svgReactAnnotationRule(_ref3) {
  var d = _ref3.d,
      i = _ref3.i,
      projectedNodes = _ref3.projectedNodes,
      nodeIDAccessor = _ref3.nodeIDAccessor;

  var selectedNode = d.x && d.y ? d : projectedNodes.find(function (p) {
    return nodeIDAccessor(p) === d.id;
  });
  if (!selectedNode) {
    return null;
  }
  var noteData = _extends({
    dx: 0,
    dy: 0,
    x: selectedNode.x,
    y: selectedNode.y,
    note: { label: d.label },
    connector: { end: "arrow" }
  }, d, { type: typeof d.type === "function" ? d.type : undefined });
  return _react2.default.createElement(_Annotation2.default, { key: d.key || "annotation-" + i, noteData: noteData });
};

var svgEncloseRule = exports.svgEncloseRule = function svgEncloseRule(_ref4) {
  var d = _ref4.d,
      projectedNodes = _ref4.projectedNodes,
      nodeIDAccessor = _ref4.nodeIDAccessor,
      nodeSizeAccessor = _ref4.nodeSizeAccessor;

  var selectedNodes = projectedNodes.filter(function (p) {
    return d.ids.indexOf(nodeIDAccessor(p)) !== -1;
  });
  if (selectedNodes.length === 0) {
    return null;
  }
  var circle = (0, _d3Hierarchy.packEnclose)(selectedNodes.map(function (p) {
    return { x: p.x, y: p.y, r: nodeSizeAccessor(p) };
  }));
  return (0, _baseRules.circleEnclosure)({ circle: circle, d: d });
};

var svgRectEncloseRule = exports.svgRectEncloseRule = function svgRectEncloseRule(_ref5) {
  var d = _ref5.d,
      i = _ref5.i,
      projectedNodes = _ref5.projectedNodes,
      nodeIDAccessor = _ref5.nodeIDAccessor,
      nodeSizeAccessor = _ref5.nodeSizeAccessor;

  var selectedNodes = projectedNodes.filter(function (p) {
    return d.ids.indexOf(nodeIDAccessor(p)) !== -1;
  });
  if (selectedNodes.length === 0) {
    return null;
  }

  var bboxNodes = selectedNodes.map(function (p) {
    if (p.shapeNode) {
      return {
        x0: p.x0,
        x1: p.x1,
        y0: p.y0,
        y1: p.y1
      };
    }
    var nodeSize = nodeSizeAccessor(p);
    return {
      x0: p.x - nodeSize,
      x1: p.x + nodeSize,
      y0: p.y - nodeSize,
      y1: p.y + nodeSize
    };
  });

  return (0, _baseRules.rectangleEnclosure)({ bboxNodes: bboxNodes, d: d, i: i });
};

var svgHullEncloseRule = exports.svgHullEncloseRule = function svgHullEncloseRule(_ref6) {
  var d = _ref6.d,
      i = _ref6.i,
      projectedNodes = _ref6.projectedNodes,
      nodeIDAccessor = _ref6.nodeIDAccessor,
      nodeSizeAccessor = _ref6.nodeSizeAccessor;

  var selectedNodes = projectedNodes.filter(function (p) {
    return d.ids.indexOf(nodeIDAccessor(p)) !== -1;
  });
  if (selectedNodes.length === 0) {
    return null;
  }

  var projectedPoints = [];

  selectedNodes.forEach(function (p) {
    if (p.shapeNode) {
      projectedPoints.push({ x: p.x0, y: p.y0 });
      projectedPoints.push({ x: p.x0, y: p.y1 });
      projectedPoints.push({ x: p.x1, y: p.y0 });
      projectedPoints.push({ x: p.x1, y: p.y1 });
    } else {
      var nodeSize = nodeSizeAccessor(p);
      projectedPoints.push({ x: p.x - nodeSize, y: p.y - nodeSize });
      projectedPoints.push({ x: p.x + nodeSize, y: p.y - nodeSize });
      projectedPoints.push({ x: p.x - nodeSize, y: p.y + nodeSize });
      projectedPoints.push({ x: p.x + nodeSize, y: p.y + nodeSize });
    }
  });

  return (0, _baseRules.hullEnclosure)({ points: projectedPoints.map(function (d) {
      return [d.x, d.y];
    }), d: d, i: i });
};

var svgHighlightRule = exports.svgHighlightRule = function svgHighlightRule(_ref7) {
  var d = _ref7.d,
      networkFrameRender = _ref7.networkFrameRender;
  var nodes = networkFrameRender.nodes;
  var customMark = nodes.customMark;


  var styleFn = function styleFn() {
    return {};
  };
  if (d.style && typeof d.style === "function") {
    styleFn = d.style;
  } else if (d.style) {
    styleFn = function styleFn() {
      return d.style;
    };
  }

  var transform = "translate(" + d.x + "," + d.y + ")";
  var baseMarkProps = { forceUpdate: true };

  var HighlightMark = customMark({ d: d, styleFn: styleFn, transform: transform, baseMarkProps: baseMarkProps });

  return HighlightMark;
};