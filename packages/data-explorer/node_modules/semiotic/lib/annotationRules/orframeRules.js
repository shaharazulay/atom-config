"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.svgRectEncloseRule = exports.htmlColumnHoverRule = exports.htmlFrameHoverRule = exports.svgCategoryRule = exports.svgRRule = exports.svgEncloseRule = exports.basicReactAnnotationRule = exports.svgORRule = exports.screenProject = exports.findIDPiece = exports.svgHighlightRule = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = require("react");

var _react2 = _interopRequireDefault(_react);

var _semioticMark = require("semiotic-mark");

var _Annotation = require("../Annotation");

var _Annotation2 = _interopRequireDefault(_Annotation);

var _AnnotationCalloutCircle = require("react-annotation/lib/Types/AnnotationCalloutCircle");

var _AnnotationCalloutCircle2 = _interopRequireDefault(_AnnotationCalloutCircle);

var _AnnotationBracket = require("react-annotation/lib/Types/AnnotationBracket");

var _AnnotationBracket2 = _interopRequireDefault(_AnnotationBracket);

var _AnnotationXYThreshold = require("react-annotation/lib/Types/AnnotationXYThreshold");

var _AnnotationXYThreshold2 = _interopRequireDefault(_AnnotationXYThreshold);

var _d3Hierarchy = require("d3-hierarchy");

var _d3Array = require("d3-array");

var _pieceDrawing = require("../svg/pieceDrawing");

var _baseRules = require("./baseRules");

var _SpanOrDiv = require("../SpanOrDiv");

var _SpanOrDiv2 = _interopRequireDefault(_SpanOrDiv);

var _multiAccessorUtils = require("../data/multiAccessorUtils");

var _d3Scale = require("d3-scale");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function polarToCartesian(centerX, centerY, radius, angleInDegrees) {
  var angleInRadians = (angleInDegrees - 90) * Math.PI / 180.0;

  return {
    x: centerX + radius * Math.cos(angleInRadians),
    y: centerY + radius * Math.sin(angleInRadians)
  };
}

function pieContentGenerator(_ref) {
  var column = _ref.column,
      useSpans = _ref.useSpans;

  return _react2.default.createElement(
    _SpanOrDiv2.default,
    { span: useSpans, className: "tooltip-content" },
    _react2.default.createElement(
      "p",
      { key: "or-annotation-1" },
      column.name
    ),
    _react2.default.createElement(
      "p",
      { key: "or-annotation-2" },
      (column.pct * 100).toFixed(0) + "%"
    )
  );
}

function arcBracket(_ref2) {
  var x = _ref2.x,
      y = _ref2.y,
      radius = _ref2.radius,
      startAngle = _ref2.startAngle,
      endAngle = _ref2.endAngle,
      inset = _ref2.inset,
      outset = _ref2.outset,
      _ref2$curly = _ref2.curly,
      curly = _ref2$curly === undefined ? true : _ref2$curly;

  var start = polarToCartesian(x, y, radius + outset, endAngle);
  var end = polarToCartesian(x, y, radius + outset, startAngle);

  var innerStart = polarToCartesian(x, y, radius + outset - inset, endAngle);
  var innerEnd = polarToCartesian(x, y, radius + outset - inset, startAngle);

  var angleSize = endAngle - startAngle;
  var largeArcFlag = angleSize <= 180 ? "0" : "1";
  var d = void 0;
  if (curly) {
    var curlyOffset = Math.min(10, angleSize / 4);

    var middleLeft = polarToCartesian(x, y, radius + outset, (startAngle + endAngle) / 2 + curlyOffset);

    var middle = polarToCartesian(x, y, radius + outset + 10, (startAngle + endAngle) / 2);
    var middleRight = polarToCartesian(x, y, radius + outset, (startAngle + endAngle) / 2 - curlyOffset);

    d = ["M", innerStart.x, innerStart.y, "L", start.x, start.y, "A", radius + outset, radius + outset, 0, 0, 0, middleLeft.x, middleLeft.y, "A", radius + outset, radius + outset, 1, 0, 1, middle.x, middle.y, "A", radius + outset, radius + outset, 1, 0, 1, middleRight.x, middleRight.y, "A", radius + outset, radius + outset, 0, 0, 0, end.x, end.y, "L", innerEnd.x, innerEnd.y].join(" ");
  } else {
    d = ["M", innerStart.x, innerStart.y, "L", start.x, start.y, "A", radius + outset, radius + outset, 0, largeArcFlag, 0, end.x, end.y, "L", innerEnd.x, innerEnd.y].join(" ");
  }

  var midAngle = (startAngle + endAngle) / 2;
  var textOffset = void 0,
      largeTextArcFlag = void 0,
      finalTextEnd = void 0,
      finalTextStart = void 0,
      arcFlip = void 0;
  var lowerArc = midAngle > 90 && midAngle < 270;
  if (lowerArc) {
    textOffset = 12;
    largeTextArcFlag = endAngle - startAngle <= 180 ? "0" : "1";
    arcFlip = 0;
  } else {
    largeTextArcFlag = endAngle - startAngle <= 180 ? "0" : "1";
    textOffset = 5;
    arcFlip = 1;
  }
  textOffset += curly ? 10 : 0;
  var textStart = polarToCartesian(x, y, radius + outset + textOffset, endAngle);
  var textEnd = polarToCartesian(x, y, radius + outset + textOffset, startAngle);
  if (lowerArc) {
    finalTextStart = textStart;
    finalTextEnd = textEnd;
  } else {
    finalTextStart = textEnd;
    finalTextEnd = textStart;
  }

  var textD = ["M", finalTextStart.x, finalTextStart.y, "A", radius + outset + textOffset, radius + outset + textOffset, arcFlip, largeTextArcFlag, arcFlip, finalTextEnd.x, finalTextEnd.y].join(" ");

  return { arcPath: d, textArcPath: textD };
}

var svgHighlightRule = exports.svgHighlightRule = function svgHighlightRule(_ref3) {
  var d = _ref3.d,
      pieceIDAccessor = _ref3.pieceIDAccessor,
      orFrameRender = _ref3.orFrameRender,
      oAccessor = _ref3.oAccessor;

  var thisID = pieceIDAccessor(d);
  var thisO = (0, _multiAccessorUtils.findFirstAccessorValue)(oAccessor, d);

  var foundPieces = orFrameRender.pieces && orFrameRender.pieces.data.filter(function (p) {
    return (thisID === undefined || pieceIDAccessor(p.piece.data) === thisID) && (thisO === undefined || (0, _multiAccessorUtils.findFirstAccessorValue)(oAccessor, p.piece.data) === thisO);
  }).map(function (p, q) {
    if (_react2.default.isValidElement(p.renderElement)) {
      console.error("OrdinalFrame highlighting currently only works with built-in pieces and not custom pieces");
      return null;
    }
    var styleObject = {
      style: {}
    };
    if (d.style && typeof d.style === "function") {
      styleObject = { style: d.style(p.piece.data) };
    } else if (d.style) {
      styleObject = { style: d.style };
    }
    var styledD = _extends({}, p.renderElement, styleObject);
    var className = "highlight-annotation " + (d.class && typeof d.class === "function" && d.class(p.piece.data, q) || d.class && d.class || "");

    return _react2.default.createElement(_semioticMark.Mark, _extends({
      fill: "none",
      stroke: "black",
      strokeWidth: "2px",
      key: "highlight-piece-" + q
    }, styledD, {
      className: className
    }));
  }) || [];
  /*
  const foundSummaries =
    (orFrameRender.summaries &&
      orFrameRender.summaries.data
        .filter(p => {
          return oAccessor(p.piece.data) === thisID
        })
        .map(p => {
          if (React.isValidElement(p.renderElement)) {
            console.error(
              "OrdinalFrame highlighting currently only works with built-in pieces and not custom pieces"
            )
            return null
          }
          let styleObject = {
            style: { fill: "none", stroke: "black", strokeWidth: "2px" }
          }
          if (d.style && typeof d.style === "function") {
            styleObject = { style: d.style(p.piece.data) }
          } else if (d.style) {
            styleObject = { style: d.style }
          }
          const styledD = { ...p.renderElement, ...styleObject }
           return <Mark {...styledD} />
        })) ||
    []
  */

  return [].concat(_toConsumableArray(foundPieces));
};

var findIDPiece = exports.findIDPiece = function findIDPiece(pieceIDAccessor, oColumn, d) {
  var pieceID = pieceIDAccessor(d);
  if (pieceID === "") return d;
  var basePiece = pieceIDAccessor(d) && oColumn && oColumn.pieceData.find(function (r) {
    return pieceIDAccessor(r.data) === pieceIDAccessor(d);
  });

  var reactAnnotationProps = ["type", "label", "note", "connector", "disabled", "color", "subject"];

  if (basePiece) {
    reactAnnotationProps.forEach(function (prop) {
      if (d[prop]) basePiece[prop] = d[prop];
    });
  }

  return basePiece;
};

var screenProject = exports.screenProject = function screenProject(_ref4) {
  var p = _ref4.p,
      adjustedSize = _ref4.adjustedSize,
      rScale = _ref4.rScale,
      oColumn = _ref4.oColumn,
      rAccessor = _ref4.rAccessor,
      idPiece = _ref4.idPiece,
      projection = _ref4.projection;

  var pValue = (0, _multiAccessorUtils.findFirstAccessorValue)(rAccessor, p) || p.value;

  var o = void 0;
  if (oColumn) {
    o = oColumn.middle;
  } else {
    o = 0;
  }

  if (oColumn && projection === "radial") {
    return (0, _pieceDrawing.pointOnArcAtAngle)([adjustedSize[0] / 2, adjustedSize[1] / 2], oColumn.pct_middle, idPiece && (idPiece.x || idPiece.scaledValue) ? idPiece.x / 2 || (idPiece.bottom + idPiece.scaledValue / 2) / 2 : pValue / 2);
  }
  if (projection === "horizontal") {
    return [idPiece && (idPiece.x || idPiece.scaledValue) ? idPiece.x || idPiece.bottom + idPiece.scaledValue / 2 : rScale(pValue), o];
  }
  var newScale = (0, _d3Scale.scaleLinear)().domain(rScale.domain()).range(rScale.range().reverse());

  return [o, idPiece && (idPiece.x || idPiece.scaledValue) ? idPiece.y || idPiece.bottom - idPiece.scaledValue / 2 : newScale(pValue)];
};

var svgORRule = exports.svgORRule = function svgORRule(_ref5) {
  var d = _ref5.d,
      i = _ref5.i,
      screenCoordinates = _ref5.screenCoordinates,
      projection = _ref5.projection;

  return _react2.default.createElement(
    _semioticMark.Mark,
    {
      markType: "text",
      key: d.label + "annotationtext" + i,
      forceUpdate: true,
      x: screenCoordinates[0] + (projection === "horizontal" ? 10 : 0),
      y: screenCoordinates[1] + (projection === "vertical" ? 10 : 0),
      className: "annotation annotation-or-label " + (d.className || ""),
      textAnchor: "middle"
    },
    d.label
  );
};

var basicReactAnnotationRule = exports.basicReactAnnotationRule = function basicReactAnnotationRule(_ref6) {
  var d = _ref6.d,
      i = _ref6.i,
      screenCoordinates = _ref6.screenCoordinates;

  var noteData = _extends({
    dx: 0,
    dy: 0,
    note: { label: d.label },
    connector: { end: "arrow" }
  }, d, {
    x: screenCoordinates[0],
    y: screenCoordinates[1],
    type: typeof d.type === "function" ? d.type : undefined,
    screenCoordinates: screenCoordinates
  });
  if (d.fixedX) noteData.x = d.fixedX;
  if (d.fixedY) noteData.y = d.fixedY;
  return _react2.default.createElement(_Annotation2.default, { key: d.key || "annotation-" + i, noteData: noteData });
};

var svgEncloseRule = exports.svgEncloseRule = function svgEncloseRule(_ref7) {
  var d = _ref7.d,
      i = _ref7.i,
      screenCoordinates = _ref7.screenCoordinates;

  var circle = (0, _d3Hierarchy.packEnclose)(screenCoordinates.map(function (p) {
    return { x: p[0], y: p[1], r: 2 };
  }));

  return (0, _baseRules.circleEnclosure)({ d: d, i: i, circle: circle });
};

var svgRRule = exports.svgRRule = function svgRRule(_ref8) {
  var d = _ref8.d,
      i = _ref8.i,
      screenCoordinates = _ref8.screenCoordinates,
      rScale = _ref8.rScale,
      rAccessor = _ref8.rAccessor,
      adjustedSize = _ref8.adjustedSize,
      adjustedPosition = _ref8.adjustedPosition,
      projection = _ref8.projection;

  var x = void 0,
      y = void 0,
      xPosition = void 0,
      yPosition = void 0,
      subject = void 0,
      dx = void 0,
      dy = void 0;
  if (projection === "radial") {
    return _react2.default.createElement(_Annotation2.default, {
      key: d.key || "annotation-" + i,
      noteData: _extends({
        dx: 50,
        dy: 50,
        note: { label: d.label },
        connector: { end: "arrow" }
      }, d, {
        type: _AnnotationCalloutCircle2.default,
        subject: {
          radius: rScale((0, _multiAccessorUtils.findFirstAccessorValue)(rAccessor, d)) / 2,
          radiusPadding: 0
        },
        x: adjustedSize[0] / 2,
        y: adjustedSize[1] / 2
      })
    });
  } else if (projection === "horizontal") {
    dx = 50;
    dy = 50;
    yPosition = d.offset || i * 25;
    x = screenCoordinates[0];
    y = yPosition;
    subject = {
      x: x,
      y1: 0,
      y2: adjustedSize[1] + adjustedPosition[1]
    };
  } else {
    dx = 50;
    dy = -20;
    xPosition = d.offset || i * 25;
    y = screenCoordinates[1];
    x = xPosition;
    subject = {
      y: y,
      x1: 0,
      x2: adjustedSize[0] + adjustedPosition[0]
    };
  }

  var noteData = _extends({
    dx: dx,
    dy: dy,
    note: { label: d.label },
    connector: { end: "arrow" }
  }, d, {
    type: _AnnotationXYThreshold2.default,
    x: x,
    y: y,
    subject: subject
  });
  return _react2.default.createElement(_Annotation2.default, { key: d.key || "annotation-" + i, noteData: noteData });
};

var svgCategoryRule = exports.svgCategoryRule = function svgCategoryRule(_ref9) {
  var projection = _ref9.projection,
      d = _ref9.d,
      i = _ref9.i,
      categories = _ref9.categories,
      adjustedSize = _ref9.adjustedSize;
  var _d$bracketType = d.bracketType,
      bracketType = _d$bracketType === undefined ? "curly" : _d$bracketType,
      _d$position = d.position,
      position = _d$position === undefined ? projection === "vertical" ? "top" : "left" : _d$position,
      _d$depth = d.depth,
      depth = _d$depth === undefined ? 30 : _d$depth,
      _d$offset = d.offset,
      offset = _d$offset === undefined ? 0 : _d$offset,
      _d$padding = d.padding,
      padding = _d$padding === undefined ? 0 : _d$padding;

  var actualCategories = Array.isArray(d.categories) ? d.categories : [d.categories];

  var cats = actualCategories.map(function (c) {
    return categories[c];
  });

  if (projection === "radial") {
    var arcPadding = padding / adjustedSize[1];
    var leftX = (0, _d3Array.min)(cats.map(function (p) {
      return p.pct_start + p.pct_padding / 2 + arcPadding / 2;
    }));
    var rightX = (0, _d3Array.max)(cats.map(function (p) {
      return p.pct_start + p.pct - p.pct_padding / 2 - arcPadding / 2;
    }));

    var chartSize = Math.min(adjustedSize[0], adjustedSize[1]) / 2;
    var centerX = adjustedSize[0] / 2;
    var centerY = adjustedSize[1] / 2;

    var _arcBracket = arcBracket({
      x: 0,
      y: 0,
      radius: chartSize,
      startAngle: leftX * 360,
      endAngle: rightX * 360,
      inset: depth,
      outset: offset,
      curly: bracketType === "curly"
    }),
        arcPath = _arcBracket.arcPath,
        textArcPath = _arcBracket.textArcPath;

    var textPathID = "text-path-" + i + "-" + Math.random();
    return _react2.default.createElement(
      "g",
      {
        className: "category-annotation annotation",
        transform: "translate(" + centerX + "," + centerY + ")"
      },
      _react2.default.createElement("path", { d: arcPath, fill: "none", stroke: "black" }),
      _react2.default.createElement("path", { id: textPathID, d: textArcPath, style: { display: "none" } }),
      _react2.default.createElement(
        "text",
        { "font-size": "12.5" },
        _react2.default.createElement(
          "textPath",
          {
            startOffset: "50%",
            textAnchor: "middle",
            xlinkHref: "#" + textPathID
          },
          d.label
        )
      )
    );
  } else {
    var _leftX = (0, _d3Array.min)(cats.map(function (p) {
      return p.x;
    }));
    var _rightX = (0, _d3Array.max)(cats.map(function (p) {
      return p.x + p.width;
    }));

    if (projection === "vertical") {
      var yPosition = position === "top" ? 0 : adjustedSize[1];
      yPosition += position === "top" ? -offset : offset;
      var noteData = {
        type: _AnnotationBracket2.default,
        y: yPosition,
        x: _leftX - padding,
        note: {
          title: d.title || d.label,
          label: d.title ? d.label : undefined
        },
        subject: {
          type: bracketType,
          width: _rightX - _leftX + padding * 2,
          depth: position === "top" ? -depth : depth
        }
      };
      return _react2.default.createElement(_Annotation2.default, { key: d.key || "annotation-" + i, noteData: noteData });
    } else if (projection === "horizontal") {
      var _yPosition = position === "left" ? 0 : adjustedSize[0];
      _yPosition += position === "left" ? -offset : offset;
      var _noteData = {
        type: _AnnotationBracket2.default,
        x: _yPosition,
        y: _leftX - padding,
        note: {
          title: d.title || d.label,
          label: d.title ? d.label : undefined
        },
        subject: {
          type: bracketType,
          height: _rightX - _leftX + padding * 2,
          depth: position === "left" ? -depth : depth
        }
      };
      return _react2.default.createElement(_Annotation2.default, { key: d.key || "annotation-" + i, noteData: _noteData });
    }
  }
};

var htmlFrameHoverRule = exports.htmlFrameHoverRule = function htmlFrameHoverRule(_ref10) {
  var d = _ref10.d,
      i = _ref10.i,
      rAccessor = _ref10.rAccessor,
      oAccessor = _ref10.oAccessor,
      projection = _ref10.projection,
      tooltipContent = _ref10.tooltipContent,
      useSpans = _ref10.useSpans,
      pieceIDAccessor = _ref10.pieceIDAccessor,
      projectedColumns = _ref10.projectedColumns,
      adjustedSize = _ref10.adjustedSize,
      rScale = _ref10.rScale,
      type = _ref10.type;

  tooltipContent = tooltipContent === "pie" ? function () {
    return pieContentGenerator({
      column: d.column,
      useSpans: useSpans
    });
  } : tooltipContent;
  //To string because React gives a DOM error if it gets a date
  var contentFill = void 0;
  var pO = (0, _multiAccessorUtils.findFirstAccessorValue)(oAccessor, d) || d.column;
  var oColumn = projectedColumns[pO];

  var idPiece = findIDPiece(pieceIDAccessor, oColumn, d);

  if (!idPiece) {
    return null;
  }

  var screenCoordinates = type.type === "clusterbar" || d.isSummaryData ? [d.x, d.y] : screenProject({
    p: d,
    adjustedSize: adjustedSize,
    rScale: rScale,
    oColumn: oColumn,
    oAccessor: oAccessor,
    rAccessor: rAccessor,
    idPiece: idPiece,
    projection: projection
  });

  if (d.isSummaryData) {
    var summaryContent = d.label;

    if (d.pieces && d.pieces.length !== 0) {
      if (d.pieces.length === 1) {
        summaryContent = [];
        rAccessor.forEach(function (actualRAccessor) {
          summaryContent.push(actualRAccessor(d.pieces[0].data));
        });
      } else {
        summaryContent = [];
        rAccessor.forEach(function (actualRAccessor) {
          var pieceData = (0, _d3Array.extent)(d.pieces.map(function (p) {
            return p.data;
          }).map(actualRAccessor));
          summaryContent.push("From " + pieceData[0] + " to " + pieceData[1]);
        });
      }
    }
    var summaryLabel = _react2.default.createElement(
      "p",
      { key: "html-annotation-content-2" },
      summaryContent
    );
    contentFill = [_react2.default.createElement(
      "p",
      { key: "html-annotation-content-1" },
      d.key
    ), summaryLabel, _react2.default.createElement(
      "p",
      { key: "html-annotation-content-3" },
      d.value
    )];
  } else if (d.data) {
    contentFill = [];

    oAccessor.forEach(function (actualOAccessor, i) {
      if (actualOAccessor(idPiece.data)) contentFill.push(_react2.default.createElement(
        "p",
        { key: "html-annotation-content-o-" + i },
        actualOAccessor(idPiece.data).toString()
      ));
    });

    rAccessor.forEach(function (actualRAccessor, i) {
      if (actualRAccessor(idPiece.data)) contentFill.push(_react2.default.createElement(
        "p",
        { key: "html-annotation-content-r-" + i },
        actualRAccessor(idPiece.data).toString()
      ));
    });
  } else if (d.label) {
    contentFill = d.label;
  }
  var content = _react2.default.createElement(
    _SpanOrDiv2.default,
    { span: useSpans, className: "tooltip-content" },
    contentFill
  );

  if (d.type === "frame-hover" && tooltipContent) {
    content = tooltipContent(idPiece);
  }

  return _react2.default.createElement(
    _SpanOrDiv2.default,
    {
      span: useSpans,
      key: "xylabel-" + i,
      className: "annotation annotation-or-label " + projection + " " + (d.className || ""),
      style: {
        position: "absolute",
        top: screenCoordinates[1] + "px",
        left: screenCoordinates[0] + "px"
      }
    },
    content
  );
};

var htmlColumnHoverRule = exports.htmlColumnHoverRule = function htmlColumnHoverRule(_ref11) {
  var d = _ref11.d,
      i = _ref11.i,
      summaryType = _ref11.summaryType,
      oAccessor = _ref11.oAccessor,
      type = _ref11.type,
      adjustedPosition = _ref11.adjustedPosition,
      adjustedSize = _ref11.adjustedSize,
      projection = _ref11.projection,
      tooltipContent = _ref11.tooltipContent,
      useSpans = _ref11.useSpans,
      projectedColumns = _ref11.projectedColumns;

  //we need to ignore negative pieces to make sure the hover behavior populates on top of the positive bar

  var column = d.column || projectedColumns[d.facetColumn] || projectedColumns[(0, _multiAccessorUtils.findFirstAccessorValue)(oAccessor, d)];

  var pieces = column.pieceData || column.pieces;

  var positionValue = summaryType.type && summaryType.type !== "none" || ["swarm", "point", "clusterbar"].find(function (p) {
    return p === type.type;
  }) ? (0, _d3Array.max)(pieces.map(function (p) {
    return p.scaledValue;
  })) : projection === "horizontal" ? (0, _d3Array.max)(pieces.map(function (p) {
    return p.scaledValue + p.bottom;
  })) : (0, _d3Array.min)(pieces.map(function (p) {
    return p.bottom - p.scaledValue;
  }));

  var xPosition = column.middle + adjustedPosition[0];
  var yPosition = projection === "horizontal" ? adjustedSize[0] - positionValue : summaryType.type && summaryType.type !== "none" || ["swarm", "point", "clusterbar"].find(function (p) {
    return p === type.type;
  }) ? adjustedSize[1] - positionValue : positionValue;
  yPosition += 10;

  if (projection === "horizontal") {
    yPosition = column.middle;
    xPosition = positionValue + adjustedPosition[0];
  } else if (projection === "radial") {
    ;
    var _pointOnArcAtAngle = (0, _pieceDrawing.pointOnArcAtAngle)([d.arcAngles.translate[0], d.arcAngles.translate[1]], d.arcAngles.midAngle, d.arcAngles.length);

    var _pointOnArcAtAngle2 = _slicedToArray(_pointOnArcAtAngle, 2);

    xPosition = _pointOnArcAtAngle2[0];
    yPosition = _pointOnArcAtAngle2[1];

    yPosition += 10;
  }

  //To string because React gives a DOM error if it gets a date
  var oContent = [];
  oAccessor.forEach(function (actualOAccessor, i) {
    if (pieces[0].data) oContent.push(_react2.default.createElement(
      "p",
      { key: "or-annotation-o-" + i },
      actualOAccessor(pieces[0].data).toString()
    ));
  });

  var content = _react2.default.createElement(
    _SpanOrDiv2.default,
    { span: useSpans, className: "tooltip-content" },
    oContent,
    _react2.default.createElement(
      "p",
      { key: "or-annotation-2" },
      (0, _d3Array.sum)(pieces.map(function (p) {
        return p.value;
      }).filter(function (p) {
        return p > 0;
      }))
    )
  );

  if (d.type === "column-hover" && tooltipContent) {
    if (tooltipContent === "pie") {
      tooltipContent = pieContentGenerator;
    }

    content = tooltipContent(_extends({}, d, {
      pieces: pieces.map(function (p) {
        return p.data;
      }),
      column: column,
      oAccessor: oAccessor
    }));
  } else if (d.label) {
    content = _react2.default.createElement(
      _SpanOrDiv2.default,
      { span: useSpans, className: "tooltip-content" },
      d.label
    );
  }

  return _react2.default.createElement(
    _SpanOrDiv2.default,
    {
      span: useSpans,
      key: "orlabel-" + i,
      className: "annotation annotation-or-label " + projection + " " + (d.className || ""),
      style: {
        position: "absolute",
        top: yPosition + "px",
        left: xPosition + "px"
      }
    },
    content
  );
};

var svgRectEncloseRule = exports.svgRectEncloseRule = function svgRectEncloseRule(_ref12) {
  var d = _ref12.d,
      i = _ref12.i,
      screenCoordinates = _ref12.screenCoordinates;

  var bboxNodes = screenCoordinates.map(function (p) {
    return {
      x0: p.x0 = p[0],
      x1: p.x1 = p[0],
      y0: p.y0 = p[1],
      y1: p.y1 = p[1]
    };
  });

  return (0, _baseRules.rectangleEnclosure)({ bboxNodes: bboxNodes, d: d, i: i });
};