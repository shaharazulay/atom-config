"use strict";

var _interopRequireWildcard = require("@babel/runtime-corejs2/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.infer = infer;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/slicedToArray"));

var _getIterator2 = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/get-iterator"));

var _lodash = _interopRequireDefault(require("lodash"));

var types = _interopRequireWildcard(require("./types"));

var _error = require("./types/error");

/**
 * Infer Table Schema descriptor
 * https://github.com/frictionlessdata/tableschema-js#infer
 */
function infer(headers, values) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  // Set up default options
  var opts = _lodash.default.extend({
    rowLimit: null,
    explicit: false,
    primaryKey: null,
    cast: {}
  }, options),
      descriptor = {
    fields: []
  };

  if (opts.primaryKey) {
    if (_lodash.default.isString(opts.primaryKey)) {
      opts.primaryKey = [opts.primaryKey];
    }

    descriptor.primaryKey = opts.primaryKey;
  }

  descriptor.fields = headers.map(function (header) {
    var constraints = {},
        field = {
      name: header,
      title: "",
      description: ""
    };

    if (opts.explicit) {
      constraints.required = true;
    }

    if (_lodash.default.includes(opts.primaryKey, header)) {
      constraints.unique = true;
    }

    if (!_lodash.default.isEmpty(constraints)) {
      field.constraints = constraints;
    }

    return field;
  });
  headers.forEach(function (header, index) {
    var columnValues = _lodash.default.map(values, function (value) {
      return value[index];
    });

    var field = descriptor.fields[index];

    if (opts.rowLimit) {
      columnValues = _lodash.default.take(columnValues, opts.rowLimit);
    }

    field.type = _guessType(columnValues);

    if (opts.cast && opts.cast.hasOwnProperty.call(opts.cast, field.type)) {
      field.format = opts.cast[field.type].format;
    }

    if (!field.format) {
      field.format = "default";
    }
  });
  return descriptor;
} // Internal


var _TYPE_ORDER = ["duration", "geojson", "geopoint", "object", "array", "datetime", "time", "date", "integer", "number", "boolean", "string", "any"];

function _guessType(values) {
  // Get matching types
  var matches = [];
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = (0, _getIterator2.default)(values), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var value = _step.value;

      for (var _i = 0; _i < _TYPE_ORDER.length; _i++) {
        var type = _TYPE_ORDER[_i];
        var cast = types["cast".concat(_lodash.default.upperFirst(type))];
        var result = cast("default", value);

        if (result !== _error.ERROR) {
          matches.push(type);
          break;
        }
      }
    } // Get winner type

  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var winner = "any";
  var count = 0;
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = (0, _getIterator2.default)(_lodash.default.toPairs(_lodash.default.countBy(matches))), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var _step2$value = (0, _slicedToArray2.default)(_step2.value, 2),
          itemType = _step2$value[0],
          itemCount = _step2$value[1];

      if (itemCount > count) {
        winner = itemType;
        count = itemCount;
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  return winner;
}