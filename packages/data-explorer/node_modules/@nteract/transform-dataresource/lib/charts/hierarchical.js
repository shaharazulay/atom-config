"use strict";

var _interopRequireWildcard = require("@babel/runtime-corejs2/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.semioticHierarchicalChart = void 0;

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/objectSpread"));

var _keys = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/keys"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/toConsumableArray"));

var React = _interopRequireWildcard(require("react"));

var _d3Collection = require("d3-collection");

var _d3Scale = require("d3-scale");

var _tooltipContent = _interopRequireDefault(require("../tooltip-content"));

var parentPath = function parentPath(d, pathArray) {
  if (d.parent) {
    pathArray = parentPath(d.parent, [d.key].concat((0, _toConsumableArray2.default)(pathArray)));
  } else {
    pathArray = ["root"].concat((0, _toConsumableArray2.default)(pathArray));
  }

  return pathArray;
};

var hierarchicalTooltip = function hierarchicalTooltip(d, primaryKey, metric) {
  var pathString = d.parent ? parentPath(d.parent, d.key && [d.key] || []).join("->") : "";
  var content = [];

  if (!d.parent) {
    content.push(React.createElement("h2", {
      key: "hierarchy-title"
    }, "Root"));
  } else if (d.key) {
    content.push(React.createElement("h2", {
      key: "hierarchy-title"
    }, d.key));
    content.push(React.createElement("p", {
      key: "path-string"
    }, pathString));
    content.push(React.createElement("p", {
      key: "hierarchy-value"
    }, "Total Value: ", d.value));
    content.push(React.createElement("p", {
      key: "hierarchy-children"
    }, "Children: ", d.children.length));
  } else {
    content.push(React.createElement("p", {
      key: "leaf-label"
    }, pathString, "->", primaryKey.map(function (p) {
      return d[p];
    }).join(", ")));
    content.push(React.createElement("p", {
      key: "hierarchy-value"
    }, metric, ": ", d[metric]));
  }

  return content;
};

var hierarchicalColor = function hierarchicalColor(colorHash, d) {
  if (d.depth === 0) return "white";
  if (d.depth === 1) return colorHash[d.key];
  var colorNode = d;

  for (var x = d.depth; x > 1; x--) {
    colorNode = colorNode.parent;
  }

  var lightenScale = (0, _d3Scale.scaleLinear)().domain([6, 1]).clamp(true).range(["white", colorHash[colorNode.key]]);
  return lightenScale(d.depth);
};

var semioticHierarchicalChart = function semioticHierarchicalChart(data, schema, options) {
  var _options$hierarchyTyp = options.hierarchyType,
      hierarchyType = _options$hierarchyTyp === void 0 ? "dendrogram" : _options$hierarchyTyp,
      chart = options.chart,
      selectedDimensions = options.selectedDimensions,
      primaryKey = options.primaryKey,
      colors = options.colors;
  var metric1 = chart.metric1;

  if (selectedDimensions.length === 0) {
    return {};
  }

  var nestingParams = (0, _d3Collection.nest)();
  selectedDimensions.forEach(function (d) {
    nestingParams.key(function (p) {
      return p[d];
    });
  });
  var colorHash = {};
  var sanitizedData = [];
  data.forEach(function (d) {
    if (!colorHash[d[selectedDimensions[0]]]) colorHash[d[selectedDimensions[0]]] = colors[(0, _keys.default)(colorHash).length];
    sanitizedData.push((0, _objectSpread2.default)({}, d, {
      sanitizedR: d.r,
      r: undefined
    }));
  });
  var entries = nestingParams.entries(sanitizedData);
  var rootNode = {
    values: entries
  };
  return {
    edges: rootNode,
    edgeStyle: function edgeStyle(d) {
      return {
        fill: "lightgray",
        stroke: "gray"
      };
    },
    nodeStyle: function nodeStyle(d) {
      return {
        fill: hierarchicalColor(colorHash, d),
        stroke: d.depth === 1 ? "white" : "black",
        strokeOpacity: d.depth * 0.1 + 0.2
      };
    },
    networkType: {
      type: hierarchyType,
      hierarchySum: function hierarchySum(d) {
        return d[metric1];
      },
      hierarchyChildren: function hierarchyChildren(d) {
        return d.values;
      },
      padding: hierarchyType === "treemap" ? 3 : hierarchyType === "circlepack" ? 2 : 0
    },
    edgeRenderKey: function edgeRenderKey(d, i) {
      return i;
    },
    baseMarkProps: {
      forceUpdate: true
    },
    margin: {
      left: 100,
      right: 100,
      top: 10,
      bottom: 10
    },
    hoverAnnotation: true,
    tooltipContent: function tooltipContent(d) {
      return React.createElement(_tooltipContent.default, null, hierarchicalTooltip(d, primaryKey, metric1));
    }
  };
};

exports.semioticHierarchicalChart = semioticHierarchicalChart;