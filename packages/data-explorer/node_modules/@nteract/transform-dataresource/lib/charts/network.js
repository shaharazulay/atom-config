"use strict";

var _interopRequireWildcard = require("@babel/runtime-corejs2/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.semioticNetwork = void 0;

var _keys = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/keys"));

var React = _interopRequireWildcard(require("react"));

var _tooltipContent = _interopRequireDefault(require("../tooltip-content"));

var semioticNetwork = function semioticNetwork(data, schema, options) {
  var _options$networkType = options.networkType,
      networkType = _options$networkType === void 0 ? "force" : _options$networkType,
      chart = options.chart,
      colors = options.colors;
  var sourceDimension = chart.dim1,
      targetDimension = chart.dim2,
      metric1 = chart.metric1;

  if (!sourceDimension || sourceDimension === "none" || !targetDimension || targetDimension === "none") {
    return {};
  }

  var edgeHash = {};
  var networkData = [];
  data.forEach(function (d) {
    if (!edgeHash["".concat(d[sourceDimension], "-").concat(d[targetDimension])]) {
      edgeHash["".concat(d[sourceDimension], "-").concat(d[targetDimension])] = {
        source: d[sourceDimension],
        target: d[targetDimension],
        value: 0,
        weight: 0
      };
      networkData.push(edgeHash["".concat(d[sourceDimension], "-").concat(d[targetDimension])]);
    }

    edgeHash["".concat(d[sourceDimension], "-").concat(d[targetDimension])].value += d[metric1] || 1;
    edgeHash["".concat(d[sourceDimension], "-").concat(d[targetDimension])].weight += 1;
  });
  var colorHash = {};
  data.forEach(function (d) {
    if (!colorHash[d[sourceDimension]]) colorHash[d[sourceDimension]] = colors[(0, _keys.default)(colorHash).length % colors.length];
    if (!colorHash[d[targetDimension]]) colorHash[d[targetDimension]] = colors[(0, _keys.default)(colorHash).length % colors.length];
  });
  networkData.forEach(function (d) {
    d.weight = Math.min(10, d.weight);
  });
  return {
    edges: networkData,
    edgeType: "halfarrow",
    edgeStyle: function edgeStyle(d) {
      return {
        fill: colorHash[d.source.id],
        stroke: colorHash[d.source.id],
        strokeOpacity: 0.5
      };
    },
    nodeStyle: function nodeStyle(d) {
      return {
        fill: colorHash[d.id],
        stroke: colorHash[d.id],
        strokeOpacity: 0.5
      };
    },
    nodeSizeAccessor: function nodeSizeAccessor(d) {
      return d.degree;
    },
    networkType: {
      type: networkType,
      iterations: 1000
    },
    hoverAnnotation: true,
    tooltipContent: function tooltipContent(d) {
      return React.createElement(_tooltipContent.default, null, React.createElement("h3", null, d.id), React.createElement("p", null, "Links: ", d.degree), d.value && React.createElement("p", null, "Value: ", d.value));
    },
    margin: {
      left: 100,
      right: 100,
      top: 10,
      bottom: 10
    }
  };
};

exports.semioticNetwork = semioticNetwork;