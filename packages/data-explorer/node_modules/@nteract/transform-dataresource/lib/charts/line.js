"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

var _interopRequireWildcard = require("@babel/runtime-corejs2/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.semioticLineChart = void 0;

var React = _interopRequireWildcard(require("react"));

var _tooltipContent = _interopRequireDefault(require("../tooltip-content"));

var _d3Shape = require("d3-shape");

var _d3Scale = require("d3-scale");

var _utilities = require("../utilities");

var semioticLineChart = function semioticLineChart(data, schema, options) {
  var lineData;
  var chart = options.chart,
      selectedMetrics = options.selectedMetrics,
      lineType = options.lineType,
      metrics = options.metrics,
      dimensions = options.dimensions,
      primaryKey = options.primaryKey,
      colors = options.colors;
  var timeseriesSort = chart.timeseriesSort;
  var sortType = timeseriesSort === "array-order" ? "integer" : schema.fields.find(function (p) {
    return p.name === timeseriesSort;
  }).type;
  var formatting = sortType === "datetime" ? function (d) {
    return d.toLocaleString().split(",")[0];
  } : _utilities.numeralFormatting;
  var xScale = sortType === "datetime" ? (0, _d3Scale.scaleTime)() : (0, _d3Scale.scaleLinear)();
  lineData = metrics.map(function (d, i) {
    var metricData = timeseriesSort === "array-order" ? data : data.sort(function (a, b) {
      return a[timeseriesSort] - b[timeseriesSort];
    });
    return {
      color: colors[i % colors.length],
      label: d.name,
      type: d.type,
      coordinates: metricData.map(function (p, q) {
        return {
          value: p[d.name],
          x: timeseriesSort === "array-order" ? q : p[timeseriesSort],
          label: d.name,
          color: colors[i % colors.length],
          originalData: p
        };
      })
    };
  }).filter(function (d) {
    return selectedMetrics.length === 0 || selectedMetrics.find(function (p) {
      return p === d.label;
    });
  });
  return {
    lineType: {
      type: lineType,
      interpolator: _d3Shape.curveMonotone
    },
    lines: lineData,
    xScaleType: xScale,
    renderKey: function renderKey(d, i) {
      return d.coordinates ? "line-".concat(d.label) : "linepoint=".concat(d.label, "-").concat(i);
    },
    lineStyle: function lineStyle(d) {
      return {
        fill: lineType === "line" ? "none" : d.color,
        stroke: d.color,
        fillOpacity: 0.75
      };
    },
    pointStyle: function pointStyle(d) {
      return {
        fill: d.color,
        fillOpacity: 0.75
      };
    },
    axes: [{
      orient: "left",
      tickFormat: _utilities.numeralFormatting
    }, {
      orient: "bottom",
      ticks: 5,
      tickFormat: function tickFormat(d) {
        var label = formatting(d);
        var rotation = label.length > 4 ? "45" : "0";
        var textAnchor = label.length > 4 ? "start" : "middle";
        return React.createElement("text", {
          transform: "rotate(".concat(rotation, ")"),
          textAnchor: textAnchor
        }, label);
      }
    }],
    hoverAnnotation: true,
    xAccessor: "x",
    yAccessor: "value",
    showLinePoints: lineType === "line",
    margin: {
      top: 20,
      right: 200,
      bottom: sortType === "datetime" ? 80 : 40,
      left: 50
    },
    legend: {
      title: "Legend",
      position: "right",
      width: 200,
      legendGroups: [{
        label: "",
        styleFn: function styleFn(d) {
          return {
            fill: d.color
          };
        },
        items: lineData
      }]
    },
    tooltipContent: function tooltipContent(d) {
      return React.createElement(_tooltipContent.default, null, React.createElement("p", null, d.parentLine && d.parentLine.label), React.createElement("p", null, d.value && d.value.toLocaleString() || d.value), React.createElement("p", null, timeseriesSort, ": ", formatting(d.x)), primaryKey.map(function (k, ki) {
        return React.createElement("p", {
          key: "key-".concat(ki)
        }, k, ":", " ", d.originalData[k].toString && d.originalData[k].toString() || d.originalData[k]);
      }));
    }
  };
};

exports.semioticLineChart = semioticLineChart;