"use strict";

var _interopRequireWildcard = require("@babel/runtime-corejs2/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.semioticScatterplot = exports.semioticHexbin = void 0;

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/objectSpread"));

var _keys = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/keys"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/toConsumableArray"));

var React = _interopRequireWildcard(require("react"));

var _shared = require("./shared");

var _d3Scale = require("d3-scale");

var _utilities = require("../utilities");

var _HTMLLegend = _interopRequireDefault(require("../HTMLLegend"));

var _tooltipContent = _interopRequireDefault(require("../tooltip-content"));

var steps = ["none", "#FBEEEC", "#f3c8c2", "#e39787", "#ce6751", "#b3331d"];
var thresholds = (0, _d3Scale.scaleThreshold)().domain([0.01, 0.2, 0.4, 0.6, 0.8]).range(steps);

function combineTopAnnotations(topQ, topSecondQ, dim2) {
  var combinedAnnotations = [];
  var combinedHash = {};
  (0, _toConsumableArray2.default)(topQ).concat((0, _toConsumableArray2.default)(topSecondQ)).forEach(function (d) {
    var hashD = combinedHash[d[dim2]];

    if (hashD) {
      var newCoordinates = hashD.coordinates && (0, _toConsumableArray2.default)(hashD.coordinates).concat([d]) || [d, hashD];
      (0, _keys.default)(combinedHash[d[dim2]]).forEach(function (k) {
        delete combinedHash[d[dim2]][k];
      });
      combinedHash[d[dim2]].id = d[dim2];
      combinedHash[d[dim2]].label = d[dim2];
      combinedHash[d[dim2]].type = "react-annotation";
      combinedHash[d[dim2]].coordinates = newCoordinates;
    } else {
      combinedHash[d[dim2]] = (0, _objectSpread2.default)({
        type: "react-annotation",
        label: d[dim2],
        id: d[dim2]
      }, d);
      combinedAnnotations.push(combinedHash[d[dim2]]);
    }
  });
  return combinedAnnotations;
}

var semioticHexbin = function semioticHexbin(data, schema, options) {
  return semioticScatterplot(data, schema, options, options.areaType);
};

exports.semioticHexbin = semioticHexbin;

var semioticScatterplot = function semioticScatterplot(data, schema, options) {
  var type = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "scatterplot";
  var height = options.height - 150 || 500;
  var chart = options.chart,
      primaryKey = options.primaryKey,
      colors = options.colors,
      setColor = options.setColor,
      dimensions = options.dimensions;
  var dim1 = chart.dim1,
      dim2 = chart.dim2,
      dim3 = chart.dim3,
      metric1 = chart.metric1,
      metric2 = chart.metric2,
      metric3 = chart.metric3;
  var filteredData = data.filter(function (d) {
    return d[metric1] && d[metric2] && (!metric3 || metric3 === "none" || d[metric3]);
  });

  var pointTooltip = function pointTooltip(d) {
    return React.createElement(_tooltipContent.default, null, React.createElement("h3", null, primaryKey.map(function (p) {
      return d[p];
    }).join(", ")), dimensions.map(function (dim) {
      return React.createElement("p", {
        key: "tooltip-dim-".concat(dim.name)
      }, dim.name, ":", " ", d[dim.name].toString && d[dim.name].toString() || d[dim.name]);
    }), React.createElement("p", null, metric1, ": ", d[metric1]), React.createElement("p", null, metric2, ": ", d[metric2]), metric3 && metric3 !== "none" && React.createElement("p", null, metric3, ": ", d[metric3]));
  };

  var areaTooltip = function areaTooltip(d) {
    if (d.binItems.length === 0) return null;
    return React.createElement(_tooltipContent.default, null, React.createElement("h3", {
      style: {
        fontSize: "14px",
        textTransform: "uppercase",
        margin: "5px",
        fontWeight: 900
      }
    }, "ID, ", metric1, ", ", metric2), d.binItems.map(function (d) {
      return React.createElement("p", {
        style: {
          fontSize: "12px",
          textTransform: "uppercase",
          margin: "5px"
        }
      }, dimensions.map(function (dim) {
        return d[dim.name].toString && d[dim.name].toString() || d[dim.name];
      }).join(","), ", ", d[metric1], ", ", d[metric2]);
    }));
  };

  var sizeScale = function sizeScale(e) {
    return 5;
  };

  var colorHash = {
    Other: "grey"
  };
  var additionalSettings = {};
  var annotations;

  if (dim2 && dim2 !== "none") {
    var topQ = (0, _toConsumableArray2.default)(filteredData).sort(function (a, b) {
      return b[metric1] - a[metric1];
    }).filter(function (d, i) {
      return i < 3;
    });
    var topSecondQ = (0, _toConsumableArray2.default)(filteredData).sort(function (a, b) {
      return b[metric2] - a[metric2];
    }).filter(function (d) {
      return topQ.indexOf(d) === -1;
    }).filter(function (d, i) {
      return i < 3;
    });
    annotations = combineTopAnnotations(topQ, topSecondQ, dim2);
  }

  if (metric3 && metric3 !== "none") {
    var dataMin = Math.min.apply(Math, (0, _toConsumableArray2.default)(filteredData.map(function (d) {
      return d[metric3];
    })));
    var dataMax = Math.max.apply(Math, (0, _toConsumableArray2.default)(filteredData.map(function (d) {
      return d[metric3];
    })));
    sizeScale = (0, _d3Scale.scaleLinear)().domain([dataMin, dataMax]).range([2, 20]);
  }

  var sortedData = (0, _shared.sortByOrdinalRange)(metric1, metric3 !== "none" && metric3 || metric2, "none", data);

  if ((type === "scatterplot" || type === "contour") && dim1 && dim1 !== "none") {
    var uniqueValues = sortedData.reduce(function (p, c) {
      return !p.find(function (d) {
        return d === c[dim1].toString();
      }) && (0, _toConsumableArray2.default)(p).concat([c[dim1].toString()]) || p;
    }, []);
    uniqueValues.forEach(function (d, i) {
      colorHash[d] = i > 18 ? "grey" : colors[i % colors.length];
    });
    additionalSettings.afterElements = React.createElement(_HTMLLegend.default, {
      valueHash: {},
      values: uniqueValues,
      colorHash: colorHash,
      setColor: setColor,
      colors: colors
    });
  } else if (type !== "scatterplot" && type !== "contour") {
    var hexValues = ["0% - 20%", "20% - 40%", "40% - 60%", "60% - 80%", "80% - 100%"];
    var hexHash = {
      "0% - 20%": "#FBEEEC",
      "20% - 40%": "#f3c8c2",
      "40% - 60%": "#e39787",
      "60% - 80%": "#ce6751",
      "80% - 100%": "#b3331d"
    }; //    const steps = ["none", "#FBEEEC", "#f3c8c2", "#e39787", "#ce6751", "#b3331d"]

    additionalSettings.afterElements = React.createElement(_HTMLLegend.default, {
      valueHash: {},
      values: hexValues,
      colorHash: hexHash,
      colors: colors
    });
  }

  var areas;

  if (type === "heatmap" || type === "hexbin" || type === "contour" && dim3 === "none") {
    areas = [{
      coordinates: filteredData
    }];
  } else if (type === "contour") {
    var multiclassHash = {};
    areas = [];
    filteredData.forEach(function (d) {
      if (!multiclassHash[d[dim1]]) {
        multiclassHash[d[dim1]] = {
          label: d[dim1],
          color: colorHash[d[dim1]],
          coordinates: []
        };
        areas.push(multiclassHash[d[dim1]]);
      }

      multiclassHash[d[dim1]].coordinates.push(d);
    });
  }

  var renderInCanvas = (type === "scatterplot" || type === "contour") && data.length > 999;
  return (0, _objectSpread2.default)({
    xAccessor: metric1,
    yAccessor: metric2,
    axes: [{
      orient: "left",
      ticks: 6,
      label: metric2,
      tickFormat: _utilities.numeralFormatting,
      footer: type === "heatmap"
    }, {
      orient: "bottom",
      ticks: 6,
      label: metric1,
      tickFormat: _utilities.numeralFormatting,
      footer: type === "heatmap"
    }],
    points: (type === "scatterplot" || type === "contour") && data,
    canvasPoints: renderInCanvas,
    areas: areas,
    areaType: {
      type: type,
      bins: 10,
      thresholds: dim3 === "none" ? 6 : 3
    },
    areaStyle: function areaStyle(d) {
      return {
        fill: type === "contour" ? "none" : thresholds(d.percent),
        stroke: type !== "contour" ? "black" : dim3 === "none" ? "#BBB" : d.parentArea.color,
        strokeWidth: type === "contour" ? 2 : 1
      };
    },
    pointStyle: function pointStyle(d) {
      return {
        r: renderInCanvas ? 2 : type === "contour" ? 3 : sizeScale(d[metric3]),
        fill: colorHash[d[dim1]] || "black",
        fillOpacity: 0.75,
        stroke: renderInCanvas ? "none" : type === "contour" ? "white" : "black",
        strokeWidth: type === "contour" ? 0.5 : 1,
        strokeOpacity: 0.9
      };
    },
    hoverAnnotation: !renderInCanvas,
    responsiveWidth: false,
    size: [height + 200, height + 50],
    margin: {
      left: 75,
      bottom: 50,
      right: 150,
      top: 30
    },
    annotations: type === "scatterplot" && annotations || undefined,
    annotationSettings: {
      layout: {
        type: "marginalia",
        orient: "right",
        marginOffset: 30
      }
    },
    tooltipContent: (type === "hexbin" || type === "heatmap") && areaTooltip || pointTooltip
  }, additionalSettings);
};

exports.semioticScatterplot = semioticScatterplot;